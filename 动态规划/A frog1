#include<bits/stdc++.h>
using namespace std;
const int M=5e5+3;
int l[M];
int dp[M];
int main()
{
  int n;
  cin>>n;
  for(int i = 1; i <= n; i++) cin>>l[i];
  dp[2] = abs(l[2]-l[1]);
  for(int i = 3; i <= n; i++) dp[i]=min(dp[i-1]+abs(l[i]-l[i-1]),dp[i-2]+abs(l[i]-l[i-2]));
  cout<<dp[n];
}

/*
  https://atcoder.jp/contests/dp/tasks/dp_a
  初学动态规划，感觉就是大到小，小到大这种思路：
                  大到小：缩短输入（本来输入是10000，短到2，3，4这样的，），手动推公式；
                  小到大：延申已推公式；
还有打表吧；
解题心路：
刚开始做这一题，我一直找中间的，也就是子问题，但是找的是常规的（n/2），发现跟n没区别，然后就一直找不到解决无后效性的方法；
最后看了看别人的，发现还可以找（2，3，4）这种，能够推出来的，发现公式，从而代入常规的。有点像数学归纳法；
总结：我个人做题喜欢去找大的规律，不喜欢小聪明似的方法（或许是有点内心鄙视吧），导致这种像推公式的我很难真正掌握，所以后面做题我会牢记的，不搞“优越啊”；
加油；；

*/
