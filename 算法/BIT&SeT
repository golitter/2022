#include <iostream>
using namespace std;
// 树状数组
// 快速求前缀和
// 修改某一个数

int a[N], tr[N],n;
int lowbit(int x) {
    return x & (-x);
}
void add(int x, int k) {
    for(int i = x; i <= n; i +=lowbit(i)) {
        tr[i] += k;
    }
}
// update [l, r] add(l,k), add(r+1,-k);
int sum(int x) {
    int ret = 0;
    for(int i = x; i; i -= lowbit(i)) {
        ret += tr[i];
    }
    return ret;
} 
int sum(int x, int y) {
    int s1 = sum(x);
    int s2 = sum(y);
    return s2-s1;
}





// 线段树 
    // pushup 
    // pushdown 懒标记 延迟标记

// 操作
// pushup 
// build 将一段区间初始化线段树
// modify 修改 ：单点 区间（懒标记）
// query 查询查找

const int N = 500021;
int w[N];
struct Node {
    int l, r,v;
}tr[N*4];
void build(int u, int l, int r) {
    tr[u] = {l,r};
    if(l == r) return ;
    int mid = l + r >> 1;
    build(u<<1, l, mid), build(u<<1|1, mid+1, r); // [l, mid] [mid+1, r]
}
void pushup(int u) { // 由子节点的信息，来计算父节点的信息
    tr[u].v = max(tr[u<<1].v, tr[u<<1|1].v);
}
int query(int u, int l, int r) {
    if(tr[u].l >= l && tr[u].r <= r) return tr[u].v; // 树中结点，已经被完全包含在[l,r]中了
    int mid = tr[u].l + tr[u].r >> 1;
    int v = 0;
    if(l <= mid) v = query(u<<1,l,r);
    if(r > mid) v = max(v, query(u<<1|1,l,r));
    return v; 
}
void modify(int u, int x, int v) {
    if(tr[u].l == x && tr[u].r == x) tr[u].v = v;
    else {
        int mid = tr[u].r + tr[u].l >> 1;
        if(x <= mid) modify(u<<1, x,v);
        else modify(u<<1|1, x,v);
        pushup(u);
    }
}
