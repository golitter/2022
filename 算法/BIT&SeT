#include <iostream>
using namespace std;
// 树状数组
// 快速求前缀和
// 修改某一个数

int a[N], tr[N],n;
int lowbit(int x) {
    return x & (-x);
}
void add(int x, int k) {
    for(int i = x; i <= n; i +=lowbit(i)) {
        tr[i] += k;
    }
}
// update [l, r] add(l,k), add(r+1,-k);
int sum(int x) {
    int ret = 0;
    for(int i = x; i; i -= lowbit(i)) {
        ret += tr[i];
    }
    return ret;
} 
int sum(int x, int y) {
    int s1 = sum(x);
    int s2 = sum(y);
    return s2-s1;
}

#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <set>
#include <map>
#include <queue>
#include <stdio.h>
#include <algorithm>
using namespace std;

#define rep(i,x,n) for(int i = x; i <= n; i++)

typedef long long LL;
typedef pair<int,int> PII;

const int INF = 0x3f3f3f3f;
const int N = 100021;
// 区间修改，区间求和；
LL tr[N],n, str[N],ad[N];
LL lowbit(int x) {
    return x&(-x);
}
void add(int x, int k) {
    for(int i = x; i <= n; i += lowbit(i)) {
        tr[i] += k;str[i] +=k*(x-1);
    }
}
LL query(int x) {
    LL ans = 0;
    for(int i = x; i; i -= lowbit(i)) {
        //ans += tr[i];
        ans += x*tr[i] - str[i];
    }
    return ans;
}
void test();
int main()
{
    LL m;
    while(cin>>n>>m) {
        memset(ad,0,sizeof(ad));
        memset(tr,0,sizeof(tr));
        memset(str,0,sizeof(str));
    rep(i,1,n) {
        LL a; scanf("%lld",&ad[i]);
        add(i,ad[i] - ad[i-1]);
    }
    while(m--) {
        char op[2]; scanf("%s",op);
        if(*op == 'C') {
            int b,c,d; scanf("%d%d%d",&b,&c,&d); add(b,d), add(c+1,-d);
        } else {
            int c, d; scanf("%d%d",&c,&d); cout<<query(d) - query(c-1)<<endl;
        }
    }

    }
}

void test() {
    #define mytest
    #ifdef mytest
    freopen("ANSWER.txt", "w",stdout);
    #endif
}
求逆序对
for(fint i=1;i<=n;i++)
{
    cin>>a;
    adds(a,1);
    ans+=i-query(a);
}
cout<<ans;
return 0;








// 线段树 
    // pushup 
    // pushdown 懒标记 延迟标记

// 操作
// pushup 
// build 将一段区间初始化线段树
// modify 修改 ：单点 区间（懒标记）
// query 查询查找

const int N = 500021;
int w[N];
struct Node {
    int l, r,v;
}tr[N*4];
void build(int u, int l, int r) {
    tr[u] = {l,r};
    if(l == r) return ;
    int mid = l + r >> 1;
    build(u<<1, l, mid), build(u<<1|1, mid+1, r); // [l, mid] [mid+1, r]
}
void pushup(int u) { // 由子节点的信息，来计算父节点的信息
    tr[u].v = max(tr[u<<1].v, tr[u<<1|1].v);
}
int query(int u, int l, int r) {
    if(tr[u].l >= l && tr[u].r <= r) return tr[u].v; // 树中结点，已经被完全包含在[l,r]中了
    int mid = tr[u].l + tr[u].r >> 1;
    int v = 0;
    if(l <= mid) v = query(u<<1,l,r);
    if(r > mid) v = max(v, query(u<<1|1,l,r));
    return v; 
}
void modify(int u, int x, int v) {
    if(tr[u].l == x && tr[u].r == x) tr[u].v = v;
    else {
        int mid = tr[u].r + tr[u].l >> 1;
        if(x <= mid) modify(u<<1, x,v);
        else modify(u<<1|1, x,v);
        pushup(u);
    }
}
