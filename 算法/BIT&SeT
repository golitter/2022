#include <iostream>
using namespace std;
// 树状数组
// 快速求前缀和
// 修改某一个数

int a[N], tr[N],n;
int lowbit(int x) {
    return x & (-x);
}
void add(int x, int k) {
    for(int i = x; i <= n; i +=lowbit(i)) {
        tr[i] += k;
    }
}
// update [l, r] add(l,k), add(r+1,-k);
int sum(int x) {
    int ret = 0;
    for(int i = x; i; i -= lowbit(i)) {
        ret += tr[i];
    }
    return ret;
} 
int sum(int x, int y) {
    int s1 = sum(x);
    int s2 = sum(y);
    return s2-s1;
}

#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <set>
#include <map>
#include <queue>
#include <stdio.h>
#include <algorithm>
using namespace std;

#define rep(i,x,n) for(int i = x; i <= n; i++)

typedef long long LL;
typedef pair<int,int> PII;

const int INF = 0x3f3f3f3f;
const int N = 100021;
// 区间修改，区间求和；
LL tr[N],n, str[N],ad[N];
LL lowbit(int x) {
    return x&(-x);
}
void add(int x, int k) {
    for(int i = x; i <= n; i += lowbit(i)) {
        tr[i] += k;str[i] +=k*(x-1);
    }
}
LL query(int x) {
    LL ans = 0;
    for(int i = x; i; i -= lowbit(i)) {
        //ans += tr[i];
        ans += x*tr[i] - str[i];
    }
    return ans;
}
void test();
int main()
{
    LL m;
    while(cin>>n>>m) {
        memset(ad,0,sizeof(ad));
        memset(tr,0,sizeof(tr));
        memset(str,0,sizeof(str));
    rep(i,1,n) {
        LL a; scanf("%lld",&ad[i]);
        add(i,ad[i] - ad[i-1]);
    }
    while(m--) {
        char op[2]; scanf("%s",op);
        if(*op == 'C') {
            int b,c,d; scanf("%d%d%d",&b,&c,&d); add(b,d), add(c+1,-d);
        } else {
            int c, d; scanf("%d%d",&c,&d); cout<<query(d) - query(c-1)<<endl;
        }
    }

    }
}

void test() {
    #define mytest
    #ifdef mytest
    freopen("ANSWER.txt", "w",stdout);
    #endif
}
求逆序对
for(fint i=1;i<=n;i++)
{
    cin>>a;
    adds(a,1);
    ans+=i-query(a);
}
cout<<ans;
return 0;








// 线段树 
    // pushup 
    // pushdown 懒标记 延迟标记

// 操作
// pushup 
// build 将一段区间初始化线段树
// modify 修改 ：单点 区间（懒标记）
// query 查询查找

const int N = 500021;
int w[N];
struct Node {
    int l, r,v;
}tr[N*4];
void build(int u, int l, int r) {
    tr[u] = {l,r};
    if(l == r) return ;
    int mid = l + r >> 1;
    build(u<<1, l, mid), build(u<<1|1, mid+1, r); // [l, mid] [mid+1, r]
}
void pushup(int u) { // 由子节点的信息，来计算父节点的信息
    tr[u].v = max(tr[u<<1].v, tr[u<<1|1].v);
}
int query(int u, int l, int r) {
    if(tr[u].l >= l && tr[u].r <= r) return tr[u].v; // 树中结点，已经被完全包含在[l,r]中了
    int mid = tr[u].l + tr[u].r >> 1;
    int v = 0;
    if(l <= mid) v = query(u<<1,l,r);
    if(r > mid) v = max(v, query(u<<1|1,l,r));
    return v; 
}
void modify(int u, int x, int v) {
    if(tr[u].l == x && tr[u].r == x) tr[u].v = v;
    else {
        int mid = tr[u].r + tr[u].l >> 1;
        if(x <= mid) modify(u<<1, x,v);
        else modify(u<<1|1, x,v);
        pushup(u);
    }
}





#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <set>
#include <map>
#include <queue>
#include <stdio.h>
#include <algorithm>
using namespace std;

#define rep(i,x,n) for(int i = x; i <= n; i++)
// 涉及修改，新建 pushup
// 涉及查询，修改，递归 pushdown;
typedef long long LL;
typedef pair<int,int> PII;

const int INF = 0x3f3f3f3f;
const int N = 10021;
int n, m;
int w[N];
struct Node {
    int l, r;
    LL sum, add;
}tr[N*4];
void pushup(int u) {
    tr[u].sum = tr[u << 1].sum + tr[u<<1 | 1].sum;
}
void pushdown(int u) {
    auto &root = tr[u], &left = tr[u<<1], &right = tr[u<<1|1];
    if(root.add) {
        left.add += root.add, left.sum += (LL)(left.r - left.l + 1)*root.add;
        right.add += root.add, right.sum += (LL)(right.r - right.l + 1)*root.add;
        root.add = 0;
    }
}
void build(int u, int l, int r) {
    if(l == r) tr[u] = {l,r,w[r],0};
    else {
        tr[u] = {l,r};
        int mid = l + r >> 1;
        build(u<<1,l,mid), build(u<<1|1,mid+1,r);
        pushup(u);
    }
}
void modify(int u, int l, int r, int d) {
    if(tr[u].l >= l && tr[u].r <= r) {
        tr[u].sum += (LL)(tr[u].r - tr[u].l + 1)*d;
        tr[u].add +=d;
    }
    else { // 一定要分裂
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if(l <= mid) modify(u<<1,l,r,d);
        if(r > mid) modify(u<<1|1,l, r,d);
        pushup(u);
    }
}
LL query(int u, int l, int r) {
    if(tr[u].l >= l && tr[u].r <= r) return tr[u].sum;

    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    LL sum = 0;
    if(l <= mid) sum = query(u<<1,l,r);
    if(r > mid) sum += query(u<<1|1,l,r);
    return sum;
}
void test();
int main()
{

    return 0;
}

void test() {
    #define mytest
    #ifdef mytest
    freopen("ANSWER.txt", "w",stdout);
    #endif
}


luogu 线段树模板1
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <set>
#include <map>
#include <queue>
#include <stdio.h>
#include <algorithm>
using namespace std;

#define rep(i,x,n) for(int i = x; i <= n; i++)

typedef long long LL;
typedef pair<int,int> PII;

// OI.Wiki 图
const int INF = 0x3f3f3f3f;
const int N = 100021;
struct Tree {
    int l, r; 
    LL add,sum;
}tr[N*4];
int w[N];
void pushup(int u) {
    tr[u].sum = tr[u<<1].sum + tr[u<<1|1].sum;
}
void pushdown(int u) {
    auto &root = tr[u], &left = tr[u<<1], &right = tr[u<<1|1];
    if(root.add) {
        left.add += root.add, left.sum += (LL)(left.r - left.l + 1)*root.add;
        right.add += root.add, right.sum +=(LL)(right.r - right.l + 1)*root.add;
        root.add = 0;
    }
}
void build(int u, int l, int r) {
    if(l == r) tr[u] = {l,r,0,w[r]};
    else {
        tr[u] = {l,r};
        int mid = l + r >> 1;
        build(u<<1,l,mid), build(u<<1|1,mid+1,r);
        pushup(u);
    }
}
void modify(int u, int l, int r, int d) {
    if(tr[u].l >= l && tr[u].r <= r) {
        tr[u].sum += (LL)(tr[u].r - tr[u].l + 1)*d;
        tr[u].add += d;
    } else {
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
            // NOTICE: NOT [l, mid] and [mid+1,r]
        if(l <= mid) modify(u<<1,l, r,d);
        if(r > mid) modify(u<<1|1,l,r,d);
        pushup(u);
    }
}
LL query(int u, int l, int r) {
    if(tr[u].l >= l && tr[u].r <= r) return tr[u].sum;
    else {
        pushdown(u);
        LL sum = 0;
        int mid = tr[u].l + tr[u].r >> 1;
            // NOTICE: NOT [l, mid] and [mid+1, r]
        if(l <= mid) sum = query(u<<1,l,r);
        if(r > mid) sum += query(u<<1|1,l,r);
        return sum;
    }
}
void test();
int main()
{
    // w[1] = 10, w[2] = 11, w[3] = 12, w[4] = 13,w[5] = 14;
    // build(1,1,5);
    // rep(i,1,10) cout<<tr[i].sum<<" "; puts("");
    // cout<<query(1,1,5);
    int n,m; cin>>n>>m;
    rep(i,1,n) {
        scanf("%d",&w[i]);
    }
    build(1,1,n);
    while(m--) {
        int a; cin>>a;
        if(1 == a) {
            int b,c,d; cin>>b>>c>>d;
            modify(1,b,c,d);
        } else {
            int b,c; cin>>b>>c;
            cout<<query(1,b,c)<<endl;
        }
    }

    return 0;
}

void test() {
    #define mytest
    #ifdef mytest
    freopen("ANSWER.txt", "w",stdout);
    #endif
}

