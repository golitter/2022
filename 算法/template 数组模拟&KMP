#include <iostream>
#include <vector>
#include <string>
#include <set>
#include <algorithm>

// 单链表 邻接表 ：： 存储 图 和 树
// 双链表 优化某些题
/**
 * @brief 
 * @details kd
 *      head -> 3 -> 5 -> 7 -> 9-> nullptr
 *              0    1    2    3    -1
 *             e[0](3)
 *            ne[0](1);
 * 
 * 
 * @return int 
 */
using namespace std;
// this is 静态链表
const int N = 100021;
int head, e[N], ne[N], idx;
int l[N],r[N];
// head 表示头结点的下标 
// e[i] 表示结点i的值
// ne[i] 表示结点i的next指针是多少
// idx 存储当前已经用到了哪个点
void init() {
    head = -1;
    idx = 0;
}
// 将x插到头结点
void add_to_head(int x) {
    e[idx] = x;
    ne[idx] = head;
    head = idx;
    idx ++;

}
// 将x插到下标为k的点后面;
void add(int k, int x) {
    e[idx] = x;
    ne[idx] = ne[k];
    ne[k] = idx;
    idx ++;
}
// 将下标是k的点的后面的点删除
void remove(int k) {
    ne[k] = ne[ne[k]];
}

// 双链表
void init() {
    r[0] = 1;
    l[1] = 0;
    idx = 2;
}
// 在下标为k的点的右边，插入x;
void add(int k, int x) {
    e[idx] = x;
    r[idx] = r[k];
    l[idx] = l[k];
    l[r[k]] = idx;
    r[k] = idx;
}
// .......左边 add(l[k],x);
// 删除第k个点
void remove(int k) {
    r[l[k]] = r[k];
    l[r[k]] = l[k];
}

void Stack() {
    // stack;
int stk[N], tt;
// 插入
stk[++tt] = x;
// 弹出;
tt--;
// 判断是否为空
if(tt > 0 ) { // 不空

} else {
    // 空的
}
// 栈顶
stk[tt];
}
void Queue() {
    // 在队尾插入元素，在队头弹出元素；
    int q[N], hh, tt = -1;

    // 插入
    q[++tt] = x;
    // 弹出
    hh ++;
    if(hh <= tt ) {
        // empty

    } else {
        // not empty
    }
}
// 滑动窗口
void testP() { //
    int n, k;
    int a[N], q[N];
    // input all
    int hh = 0,  tt = -1;
    for(int i =0; i < n; ++i) {
        // 判读队头是否已经滑出窗口;
        if(hh <= tt && i - k +1 > q[hh]) hh++;
        while(hh <= tt && a[q[tt]] >= a[i]) tt--; // 小
        q[++tt] = i;
        if(i >= k - 1) printf("%d",a[q[hh]]);
    }
// 以最小值为例：构造一个单调队列b[i]，记h为元素下标，b中存下标。第一次：b={1}；第二次：b={1,2}（因为3>1且在范围内）；第三次：b={3}（因为队列单调递增，-1最小，所以挤掉1和3，找最小值的时候也不会轮到它们）；第四次：b={4}（1已经在外面了。-3<-1果断挤掉）；第五次：b={4,5}（5>-3 可以作为候选人）；第六次：b={4,6}（果断挤掉，有比5合适的候选人）；第七次：b={6,7}（4不在范围内，出列）；第八次：b={6,7,8}

// 每次都输出队列中的第一个元素。

// 以此维护队列中元素序号的单调性，得到结果。

// 只是比较判断，时间复杂度很小。

// 相等的值也要挤掉。

// 最大值同理。
}

// KMP算法
void KMP() {
    int p[N], s[N];
    int ne[N];
    // 求next
    int n, m;
    cin>>n>>p + 1 >> m >> s+1; // p -> small s -> big;
    // 先处理ne数组，s和自己匹配 s is smaller than p;     
    for(int i = 2,j = 0; i <= n; ++i) {
        while(j && p[i] != p[j+1]) j = ne[j]; // 往前翻记录了有相同前缀的j
        if(p[i] == p[j+1]) j++; // 匹配成功，i继续往后走
        ne[i] = j;
    }   
    // kmp 匹配过程
    for(int i = 1,j = 0; i <= m; ++i) {
        while(j && s[i] != p[j+1]) j = ne[j];
        if(s[i] == p[j+1]) j++;
        if(j == n) {
            printf("%d", i - n + 1);
            j = ne[j];
        }
    }
}
int main()
{

    return 0;
}
