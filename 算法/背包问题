#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef pair<int,int> PII;

const int N = 100021;

#define v first
#define w second


PII res[N];
int dp[N][N];
int ans[N];
// 动态规划 DP;
// 两个角度考虑： 
    // 状态表示  几维
        // 集合（所有选法）
            // 条件 
                // 只从前i个物品选
                // 中体积不超过j    
        // 属性（最大值，最小值，数量）


    // 状态计算  
        // 集合划分

    // 背包：不一定

// 01 背包 
// 特点: 每件物品最多只用一次
// n 个物品 背包V表示容量
// 物品属性 v -- 体积  w -- 权重
void knapsack11_beta1() {
    int n,v;
    cin>>n>>v;
    for(int i = 1; i <= n; ++i) cin>>res[i].first>>res[i].second;
    for(int i = 1; i <= n; ++i) {
        for(int j = 0; j <= v; ++j) { // 二维 从零开始
            dp[i][j] = dp[i-1][j];  // 不可省略哦
            if(j >= res[i].first) dp[i][j] = max(dp[i-1][j], dp[i-1][j-res[i].first] + res[i].second);

        }
    }
    cout<<dp[n][v];
}
void knapsack11_beta2() {
    int n, v;
    for(int i = 1; i <= n; ++i) {
        for(int j = v; j >= res[i].first; --j) {
            ans[j] = max(ans[j], ans[j - res[i].first] + res[i].second);
        }
    }
    cout<<ans[v];
}
// 完全背包
// 特点：物品数量无限制
void knapsackWhole_beta1() {
    int n, v;
    // input;
    for(int i = 1; i <= n; ++i) {
        for(int j = 0; j <= v; ++j) {
            for(int k = 0; k*res[i].first <= j; k++) {
                f[i][j] = max(f[i][j], f[i-1][j - res[i].first*k] + res[i].second*k);
            }
        }
    }

}
void knapsackWhole_beta2() {
    for(int i = 1; i <= n; ++i) {
        for(int j = res[i].first; j <= v; ++j) {
            ans[j] = max(ans[j], ans[j - res[i].first] + res[i].second);
        }

    }

    cout<<ans[v];

/**
 * @brief 
 *      01背包  和  完全背包 最优化 区别；
 *          01 : 从大到小
 *          11 : 从小到大
 * 
 */


}


// 多重背包
// 特点：物品有限

// 分组背包
// 特点：有组别 每组里只能选一个
int v[N], w[N], s[N];
void knapsackMany_beta1() {
    // f[i][j] = max(f[i-1][j-v[i]*k] + w[i]*k);;
    int n, v;
    cin>>n>>v;
    for(int i = 1; i <= n; ++i) cin>>v[i]>>w[i]>>s[i];
    for(int i = 1; i <= n; ++i) {
        for(int j = 0; j <= v; ++j) {
            for(int k = 0; k <= s[i] && k*v[i] <= j; ++k) {
                f[i][j] = max(f[i][j], f[i-1][j - v[i]*k] + w[i]*k);
            }
        }
    }

}
void knapsackMany_beat2() {
    for(int i = 1; i <= n; ++i) {
        if(vv[i]*s[i] >= v) {
            // 完全
            for(int j = v[i]; j <= v; ++j) {
                dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
            }
            
        } else {
            for(int j = 1; s[i] > 0; j *= 2) {
                int x = min(j, s[i]);
                for(int z = v; z >= vv[i]; --z) {
                    dp[z] = max(dp[z], dp[z - vv[i]*x] + x*w[i]);
                }
                s[i] -= x;
            }
        }
    }
}
void knapsackMany_beta2222() {

    int a, b, s,n,cnt,v;
    for(int i = 1; i <= n; ++i) {
        cin>>a>>b>>s;
        int k = 1;
        // vv w 数组要开打点;
        while(k <= s) {
            cnt++;
            v[cnt] = a*k;
            w[cnt] = b*k;
            s -= k;
            k *= 2;
        }
        if(s > 0) {
            cnt++;
            v[cnt] = a*s;
            w[cnt] = b*s;
        }
    }
    n = cnt;
    for(int i = 1; i <= n; ++i) {
        for(int j = v; j > v[i]; --j) {
            f[j] = max(f[j], f[j - v[i]] + w[i]);
        }
    }
}

int main()
{

}
