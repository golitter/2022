#include <bits/stdc++.h>
using namespace std;
// STL;
// 系统为某一个程序分配空间时，所需时间与空间大小无关，与访问次数有关。
/**
 * @brief 
 * 
 *          vector  变长数组 , 倍增的思想
 *              size() 大小
 *              empty() 空
 *              clear() 清空   : **
 *              front() back()
 *              push_back() pop_back()
 *              begin() / end()  iterator i
 *              []   支持比较运算 ， 按字典序
 *          pair<int, int>
 *              first 第一个元素
 *              second 第二个元素
 *              支持比较运算 ， 按字典序 （ 以first为第一关键字，second为第二关键字
 *          string  字符串 substr() c_str()
 *              size() empty() clear()
 * 
 *          queue   
 *              size() empty()
 *              push() 向队尾插入
 *              pop()  弹出队头
 *              front()  返回队头
 *              back()  返回队尾
 *          priority_queue 优先队列 heap 默认大根堆 小根堆 插入负数
 *              push()  插入 
 *              top()  返回堆顶
 *              pop()  弹出
 *              定义小根堆：priority_queue<int, vector<int>, greater<int>>p;
 *          stack  栈 push() top() pop() size() empty()
 *          deque  双端队列 
 *              size() empty() clear() front() back()
 *              push_back() pop_back() push_front() pop_front()
 *              iterator     
 *              [    ]
 *          set map multiset multimap  基于平衡二叉树(红黑树) 动态维护有序序列
 *  *                  size() empty() clear() 
 *              set only ,multiset not;
 *                  insert() -- 插入
 *                  find() -- 查找
 *                  count() -- 返回某一个数的个数
 *                  erase() -- 一个数，删除所有x
 *                          输入迭代器，删除这个迭代器
 *                  lower_bound(), upper_bound() >=  |> 返回迭代器
 *              map multimap
 *                  insert(x) 插入的是pair
 *                  erase(x) pair  or  iterator
 *                  find()
 *                  []
 *          unordered_set unordered_map unordered_multiset unordered_multimap --- hash  哈希表
 *              和上面类似，CRUD O(1)
 *              不支持 lower_bound() / upper_bound(),迭代器的++， --； 
 *         bitset  压位 1/8(bool)
 *              bitset<10000> s;
 *              ~ | & ^
 *              == != 
 *              []
 *              count(); 返回有多少个1
 *              any() 判读是否至少有一个1
 *              none() 判断是否全为零
 *              set(), 把所有位设置为1
 *              set(k, v) 将第k位， 变为v
 *              reset() 把所有变为0
 *              flip() 把所有位取反
 *              flip(k) 把第k位取反
 * 
 * @return int 
 */
void stlVector() {
    // init
    vector<int> a(10,3);
    vector<int> ab[34];
    // size a.size()  O(1)
    // a.empty() ()->true or false
    // 
}
void stlPair() {
    pair<int , string> p;
    p = make_pair(10, "yh");
    p = {20, "gol"};
    pair<int, pair<int,int>>pp;
}
void stlString() {
    string a = "gol";
    a += "def";
    a +='c';
    cout<<a.substr(1,2)<<endl;
    printf("%s\n",a.c_str());
}
void stlQueue() {
    queue<int> q;
    q = queue<int>();
}
void stlPriority_queue() {
    // 小根堆
    priority_queue<int, vector<int>, greater<int>>p;
}
void stlDeque() {
    ;
}
void stlSet() {
    ;
}
void stlMap() {
    map<string, int>a;
    a["yg"] = 1;
    cout<<a["yg"]<<endl;
}
void stlUnordered_
int main()
{
    stlMap();
}
