/**
 * @file Untitled-1
 * @author your name (you@domain.com)
 * @brief 
 * @version 0.1
 * @date 2022-03-17
 * 
 * @copyright Copyright (c) 2022
 * 头插法 尾插法：
 * 头插法 ：向左移动； :?先进后出 stack
 * 尾插法： 向右移动； :?先进先出 queue
 * 
 * 链表 ： 有头结点， 无头结点；
 * 两者差不多: 头插法相同，尾插法，无头结点首先加一个值，凑成有结点的即可；
 * 
 */
/**
 * 2022年3月25日 20点49分；
 */
#include <bits/stdc++.h>
using namespace std;
typedef struct list{
    int val;
    struct list *next;
}List, *LinkList;
int main()
{
    LinkList HaveHeadSuf; 
    HaveHeadSuf = new(List); // 有头结点的空链表；
    HaveHeadSuf->next = NULL;
    LinkList Tail;
    Tail = HaveHeadSuf; // 用Tail进行遍历，因为地址会变；，若用HaveHeadSuf遍历，则最后为尾指针；
    for(int i = 1; i <= 5; i++) {
        LinkList q1 = new(List);
        // q1->val = i;
        // q1->next = Tail->next; // 相当于q1向右移动；
        // Tail->next = q1; // 这一行与上面一行不要弄混，不然地址会变；
        // Tail = q1;
		// UPDATE: tail;
		q1->val = i;
		Tail->next = q1;
		Tail = Tail->next;
    }
	Tail->next = NULL;
    HaveHeadSuf = HaveHeadSuf->next;
    while(HaveHeadSuf) {
        cout<<HaveHeadSuf->val<<" ";
        HaveHeadSuf = HaveHeadSuf->next;
    }
    cout<<endl;
	// 无头结点链表尾插法同上；
}
