/**
// 对链表有了更深的理解；
刚开始我把“pHead = pHead->next”放在了“q->next = p” 的后面了，
结果一直不对，
后来想了想，
发现：
p，q，pHead 都是地址，我把"p->next = q" 意思是我把p 和 pHead 所代表的链表都给改变了，
所以每次都只有一个一个数值出现；
因为pHead 代表的链表已经被p给改变了，
所以"pHead = pHead->next" 在 “q->next = p” 前面，
这样一前一后，不会让q和pHead重叠；
例如：
1-> 2 -> 3 ->4 ->NULL;
pHead 如上：
p == pHead;
（若；
  p->next = q;
  pHead = pHead->next;
  //p->next = q equal to pHead->next = q;
  // 第二行 pHead = pHead->next equal to pHead = q;
  // 这绝对不对啊；
）
pHead = pHead->next;
p->next = q;
这样的话：
pHead 先指向下一个结点；
p 还表示 pHead;
这样 pHead 所代表的整个链表不会消失（；
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 *
 * C语言声明定义全局变量请加上static，防止重复定义
 */

/**
 * 
 * @param pHead ListNode类 
 * @return ListNode类
 */
struct ListNode* ReverseList(struct ListNode* pHead ) {
    // write code here
    struct ListNode *p, *q;
    p = NULL;
    while(pHead) {
        q = pHead;
        pHead=pHead->next;
        q->next = p;
        p = q;
    }
    return p;
}
/*
  Summarize:
  链表跟数组不一样：
  链表重点是地址，地址，地址；
  而地址是有前后结点的指针域所表示的；
  所以一不小心就改了地址，一不小心就无了；
  
*/
