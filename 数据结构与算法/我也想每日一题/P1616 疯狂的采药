/**
 * @file Untitled-3
 * @author your name (you@domain.com)
 * @brief 
 * @version 0.1
 * @date 2022-03-25
 * 
 * @copyright Copyright (c) 2022
 * 完全背包；
 * 物品可以无限取； 可以用01背包来处理；
 * 改进混动数组；
 *  for i ->0.t
 *  for j ->t[i]. m
 *  f[j] = max(f[j], f[j - t[i]] + val[i]);
 * 对于两种问题， 一种满背包问题， 一种可不满， 都是要找价值最大的；
 * for one ：dp[0. t] = -1; for two : dp = 0;
 * 
 */
#include <iostream>
#include <cstdio>
using namespace std;
typedef long long ll;
ll dp[10000002];
ll t[10003], val[10003];
int main()
{
    int time, m;
    cin>>time>>m;
    for(int i = 1; i <= m; i++) {
        scanf("%d%d",&t[i], &val[i]);
    }
    for(int i = 1; i <= m; i++) {
        for(int j = t[i]; j <= time; j++) {
            dp[j] = max(dp[j], dp[j - t[i] ] + val[i]);
        }
    }
    cout<<dp[time];
}
