[Problem - E2 - Codeforces](https://codeforces.com/contest/1537/problem/E2)

你有一个字符串 s，你可以进行两种操作。

- 删去字符串的最后一个字符。
- 将 *s* 变为 s+s，+ 表示字符串连接，也就是复制一次字符串。

你可以随意的进行操作，也可以不进行操作。

你需要找到 *s* 进行操作后获得的所有长度为 *k* 的字符串中**字典序最小**的字符串。

简单版：暴力枚举

```cpp
void solve() {
    int n,k; cin>>n>>k;
    string s; cin>>s;
    string mi = "~";
    for(int i = 1; i <= n; ++i) {
        string tmp = s.substr(0,i);
        while(tmp.size() < k) tmp += tmp;
        mi = min(mi, tmp.substr(0,k));
    }
    cout<<mi<<endl;
}
```

困难：找性质。

```cpp
void solve() {
    int n,k; cin>>n>>k;
    string s; cin>>s;
    int p = 1;
    for(int i = 1; i < n; ++i) {
        if(s[i] > s[i % p]) break;
        if(s[i] < s[i % p]) p = i + 1;
    }

    string pre = s.substr(0,p);
    while(pre.size() < k) pre += pre;
    cout<<pre.substr(0,k);
}
```

