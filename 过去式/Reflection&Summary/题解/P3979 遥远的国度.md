[P3979 遥远的国度 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3979)

问题描述：换根，路径修改，查询以某一个节点为根的最小值。

思路：树链剖分。

**注意：设置的`INF`是`0x3f3f3f3f`只会有30分，设置成int型最大值以上才能过。**

#### x和y路径上的修改

- 如果x和y的重链头父亲节点不一样，就让深度更大的那条链进行修改。

- 如果x和y在同一条链上，则按照顺序进行修改。

```cpp
void treechange(int x, int y, int k) { 
    while(top[x] != top[y]) {
        if(dep[ top[x]] < dep[ top[y]]) swap(x,y);
        modify(1, dfn[ top[x]], dfn[x], k);
        x = fa[ top[x]];
    }
    if(dep[x] > dep[y]) swap(x,y);
    modify(1, dfn[x], dfn[y], k);
}
```

#### 查询以x为根的子树中的最小值

[树链剖分（附带LCA和换根）——基于dfs序的树上优化_dazha6157的博客-CSDN博客](https://blog.csdn.net/dazha6157/article/details/101894134)

```cpp
// u 到 root路径上 与u相挨着的节点v的子树
int find_adj(int u, int rt) {
    // 从深度大的开始跳，往上跳
    while(top[u] != top[rt]) {
        if(dep[ top[u]] < dep[ top[rt]]) swap(u,rt);
        // 如果 root是u所在重链的父亲节点，那么直接返回即可
        if(fa[ top[u]] == rt) return top[u];
        u = fa[ top[u]];
    }
    // 让root深度最浅
    if(dep[u] < dep[rt]) swap(u, rt);
    return son[rt];
}
// 同上
LL nodemi(int u) {
    if(root == u) return query(1,1,n);
    else {
        int lac = lca(u, root);
        if(lac != u) return query(1, dfn[u], dfn[u] + siz[u] - 1);
        else {
            int adju = find_adj(u, root);
            int mi = INF;
            int L = dfn[adju] - 1, R = dfn[adju] + siz[adju];
            int mm1 = INF, mm2 = INF;
            if(L >= 1) mm1 = query(1, 1,L);
            if(R <= n) mm2 = query(1,R,n);
            mi = min(mm1, mm2);
            return mi;
        }
    }
}
```

AC代码：

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <set>
#include <map>
#include <queue>
#include <ctime>
#include <random>
#include <climits>
#include <sstream>
#include <numeric>
#include <stdio.h>
#include <functional>
#include <bitset>
#include <algorithm>
using namespace std;

// #define Multiple_groups_of_examples
#define IOS std::cout.tie(0);std::cin.tie(0)->sync_with_stdio(false);
#define dbgnb(a) std::cout << #a << " = " << a << '\n';
#define dbgtt cout<<" !!!test!!! "<<endl;
#define rep(i,x,n) for(int i = x; i <= n; i++)

#define all(x) (x).begin(),(x).end()
#define pb push_back
#define vf first
#define vs second

typedef long long LL;
#define int long long 
typedef pair<int,int> PII;

// const int INF = 0x3f3f3f3f;
const int INF = INT_MAX;
const int N = 5e5 + 21;

int fa[N], dep[N], siz[N], son[N], top[N], dfn[N], rnk[N];
int h[N], e[N], ne[N], w[N], dist[N], idx,cnt;
int p;
void inpfile();

void add(int u, int v) {
    e[idx] = v, ne[idx] = h[u], h[u] = idx++;
}
/* -------------------- 树链剖分 两次dfs -----------------------------------------------------------*/

// 找出 fa dep siz son
void dfs1(int u) {
    // if(dep[u]) 
    son[u] = -1; // 重儿子设置为-1
    siz[u] = 1; // 当前u节点大小为1（它本身
    for(int i = h[u]; ~i; i = ne[i]) {
        int y = e[i];
        if(y == fa[u]) continue; // ** 
        if(!dep[ y]) { // 如果深度没有，则可以接着往下遍历
            dep[ y] = dep[u] + 1; // 求出深度
            fa[ y] = u; // 为y设置父亲节点
            dfs1(y); // 递归 y
            siz[u] += siz[ y]; // 当前节点u增加子节点个数
            if(son[u] == -1 || siz[ y] > siz[ son[u]]) son[u] = y; // 更新重儿子
        }
    }
}

// 求出 top dfn rnk
void dfs2(int u, int t) {

    top[u] = t; // 设置节点u的顶部节点为t
    cnt++;
    dfn[u] = cnt; // 在线段树中的编号
    rnk[cnt] = u; // DFS序对应的节点编号
    if(son[u] == -1) return ; // 如果son[u] = -1，表示是叶子节点
    dfs2(son[u], t); // 优先对重儿子进行DFS，保证同一条重链上的点DFS序连续
    for(int i = h[u]; ~i; i = ne[i]) {
        int y = e[i];
        // 当不是u的重儿子，也不是u的父亲节点
        // 那就是新的重链
        if(y != son[u] && y != fa[u]) dfs2(y, y); 
    }
}

// 求lca
int lca(int u, int v) {
    // 当两个点的重链顶点不一样时，表示是两个不同的重链
    // 深度大的向上跳
    // 跳到重链顶点的父亲节点
    while(top[u] != top[v]) {
        if(dep[ top[u]] > dep[ top[v]]) {
            u = fa[ top[u]];
        } else {
            v = fa[ top[v]];
        }
    }
    return dep[u] > dep[v] ? v : u;
}

/* -------------------- 线段树 [ 区间修改 板子 ] --------------------------------------------------*/
// （ 裸线段树：树中点映射到线段树重
struct SegTree {
    int l,r;
    LL mi,lz;
}tr[N << 2];
inline int ls(int u) {return u << 1; }
inline int rs(int u) {return u << 1 | 1; }
void pushup(int u) {
    tr[u].mi = min(tr[ls(u)].mi, tr[rs(u)].mi);
}
void pushdown(int u) {
    auto &root = tr[u], &left = tr[ls(u)], &right = tr[rs(u)];
    if(root.lz) {
        left.lz = root.lz; left.mi = root.mi;
        right.lz = root.lz; right.mi = root.mi;
        root.lz = 0;
    }
}
void build(int u, int l, int r) {
    if(l == r) tr[u] = {l,r,w[r],0};
    else {
        tr[u] = {l,r,INF,0};
        int mid = l + r >> 1;
        build(ls(u), l, mid), build(rs(u), mid + 1, r);
        pushup(u);
    }
}
void modify(int u, int l, int r, int k) {
    if(tr[u].l >= l && tr[u].r <= r) {
        tr[u].lz = 1;
        tr[u].mi = k;
        return ;
    }
    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    if(l <= mid) modify(ls(u),l,r,k);
    if(r > mid) modify(rs(u), l, r,k);
    pushup(u);
}
LL query(int u, int l, int r) {
    if(tr[u].l >= l && tr[u].r <= r) {
        return tr[u].mi;
    }
    int mid = tr[u].l + tr[u].r >> 1;
    LL mi = INF;
    pushdown(u);
    if(l <= mid) mi = query(ls(u), l,r);
    if(r > mid) mi = min(mi, query(rs(u),l,r));
    return mi;
}
/* -------------------- 树链剖分 ------------------------------------------------------------------------*/

void treechange(int x, int y, int k) { 
    while(top[x] != top[y]) {
        if(dep[ top[x]] < dep[ top[y]]) swap(x,y);
        modify(1, dfn[ top[x]], dfn[x], k);
        x = fa[ top[x]];
    }
    if(dep[x] > dep[y]) swap(x,y);
    modify(1, dfn[x], dfn[y], k);
}
/*----------------------------- 换根操作 ------------------------------------------------------------*/
int root, n,m;

/*--------------------------------以root为根的增添，查询 ----------------------------------------------*/
// u 到 root路径上 与u相挨着的节点v的子树
int find_adj(int u, int rt) {
    // 从深度大的开始跳，往上跳
    while(top[u] != top[rt]) {
        if(dep[ top[u]] < dep[ top[rt]]) swap(u,rt);
        // 如果 root是u所在重链的父亲节点，那么直接返回即可
        if(fa[ top[u]] == rt) return top[u];
        u = fa[ top[u]];
    }
    // 让root深度最浅
    if(dep[u] < dep[rt]) swap(u, rt);
    return son[rt];
}
// 同上
LL nodemi(int u) {
    if(root == u) return query(1,1,n);
    else {
        int lac = lca(u, root);
        if(lac != u) return query(1, dfn[u], dfn[u] + siz[u] - 1);
        else {
            int adju = find_adj(u, root);
            int mi = INF;
            int L = dfn[adju] - 1, R = dfn[adju] + siz[adju];
            int mm1 = INF, mm2 = INF;
            if(L >= 1) mm1 = query(1, 1,L);
            if(R <= n) mm2 = query(1,R,n);
            mi = min(mm1, mm2);
            return mi;
        }
    }
}
int a[N];
void solve() {
    memset(h, -1, sizeof(h));
    cin>>n>>m;
    // root = 1;
    for(int i = 1; i < n; ++i) {
        int u,v; cin>>u>>v;
        add(u,v);
        add(v,u);
    }
    for(int i = 1; i <= n; ++i) cin>>a[i];
    cin>>root;
    // dbgtt
    /* ------- dfs * 2-------------------------------------*/
    dfs1(root);
    dfs2(root, root);
    /* ------- 将对应的在线段树中的位置和值进行设置 ---------*/
    for(int i = 1; i <= n; ++i) w[ dfn[i]] = a[i];
    // for(int i = 1; i <= n; ++i) cout<<dfn[i]<<endl;
    /* ------- 建树 ---------*/
    build(1,1,n);
    /* --------- 查询 -----------------------------------*/
    while(m--) {
        int opt, x,y,v; cin>>opt;
        if(opt == 1) {
            cin>>x;
            root = x;
        } else if(opt == 2) {
            cin>>x>>y>>v;
            treechange(x,y,v);
        } else {
            cin>>x;
            cout<<nodemi(x)<<endl;
        }
    }

}
signed main()
{
    #ifdef Multiple_groups_of_examples
    int T; cin>>T;
    while(T--)
    #endif
    solve();
    return 0;
}
void inpfile() {
    #define mytest
    #ifdef mytest
    freopen("ANSWER.txt", "w",stdout);
    #endif
}
```

