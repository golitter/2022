[树链剖分 - OI Wiki](https://oi.wiki/graph/hld/)

树链剖分用于将树分割成若干条链的形式，以维护树上路径的信息。具体来说，将整棵树剖分为若干条链，使它组合成线性结构，然后用其他的数据结构维护信息。

> 全是oiwiki的，不写咯

定义：

- `fa(x)`：表示节点`x`在树上的父亲
- `dep(x)`：表示节点`x`在树上的深度
- `siz(x)`：表示节点`x`的子树的节点个数
- `son(x)`：表示节点`x`的重儿子
- `top(x)`：表示节点`x`所在**重链**的顶部节点（深度最小
- `dfn(x)`：表示节点`x`的**DFS序**，也是其在线段树中的编号
- `rnk(x)`：表示DFS序所对应的节点编号，有`rnk(dfn(x)) = x`

第一次DFS求出`fa(x), dep(x), siz(x), son(x)`，第二次DFS求出`top(x), dfn(x), rnk(x)`。

```cpp
int fa[N], dep[N], siz[N], son[N], top[N], dfn[N], rnk[N];
```



#### 第一次DFS

```cpp
void dfs1(int u) {
    son[u] = -1;
    siz[u] = 1;
    for(int i = h[u]; ~i; i = ne[i]) {
      	if(p[i] == fa[u]) continue; // 不然死循环了
        if(!dep[ p[i]]) {
            dep[ p[i]] = dep[u] + 1;
            fa[ p[i]] = u;
            dfs1(p[i]);
            siz[u] += siz[ p[i]];
            if(son[u] == -1 || siz[ p[i]] > siz[ son[u]]) son[u] = p[i];
        }
    }
}
```

感觉这个`p[i]`这个看着感觉不好看懂，我改了改变量（

```cpp
// 找出 fa dep siz son
void dfs1(int u) {
    // if(dep[u]) 
    son[u] = -1; // 重儿子设置为-1
    siz[u] = 1; // 当前u节点大小为1（它本身
    for(int i = h[u]; ~i; i = ne[i]) {
        int y = e[i];
        if(y == fa[u]) continue; // ** 
        if(!dep[ y]) { // 如果深度没有，则可以接着往下遍历
            dep[ y] = dep[u] + 1; // 求出深度
            fa[ y] = u; // 为y设置父亲节点
            dfs1(y); // 递归 y
            siz[u] += siz[ y]; // 当前节点u增加子节点个数
            if(son[u] == -1 || siz[ y] > siz[ son[u]]) son[u] = y; // 更新重儿子
        }
    }
}
```



#### 第二次DFS

```cpp
void dfs2(int u, int t) {
    top[u] = t;
    cnt++;
    dfn[u] = cnt;
    rnk[cnt] = u;
    if(son[u] == -1) return ;
    dfs2(son[u], t);
    for(int i = h[u]; ~i; i = ne[i]) {
        if(p[i] != son[u] && p[i] != fa[u]) dfs2(p[i], p[i]); 
    }
}
```

```cpp
// 求出 top dfn rnk
void dfs2(int u, int t) {

    top[u] = t; // 设置节点u的顶部节点为t
    cnt++;
    dfn[u] = cnt; // 在线段树中的编号
    rnk[cnt] = u; // DFS序对应的节点编号
    if(son[u] == -1) return ; // 如果son[u] = -1，表示是叶子节点
    dfs2(son[u], t); // 优先对重儿子进行DFS，保证同一条重链上的点DFS序连续
    for(int i = h[u]; ~i; i = ne[i]) {
        int y = e[i];
        // 当不是u的重儿子，也不是u的父亲节点
        // 那就是新的重链
        if(y != son[u] && y != fa[u]) dfs2(y, y); 
    }
}
```



#### 重链剖分性质

**树上每个节点都属于且仅属于一条重链**。

重链开头的结点不一定是重子节点（因为重边是对于每一个结点都有定义的）。

在剖分时 **重边优先遍历**，最后树的 DFS 序上，重链内的 DFS 序是连续的。按 DFN 排序后的序列即为剖分后的链。

一颗子树内的 DFS 序是连续的。

可以发现，当我们向下经过一条 **轻边** 时，所在子树的大小至少会除以二。

## 应用

#### 求最近公共祖先

> 不断向上跳重链，当跳到同一条重链上时，深度较小的结点即为 LCA。
>
> 向上跳重链时需要先跳所在重链顶端深度较大的那个。

```cpp
int lca(int u, int v) {
    while(top[u] != top[v]) {
        if(dep[ top[u]] > dep[ top[v]]) {
            u = fa[ top[u]];
        } else {
            v = fa[ top[v]];
        }
    }
    return dep[u] > dep[v] ? v : u;
}
```

```cpp
// AC代码
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <set>
#include <map>
#include <queue>
#include <ctime>
#include <random>
#include <sstream>
#include <numeric>
#include <stdio.h>
#include <functional>
#include <bitset>
#include <algorithm>
using namespace std;

// #define Multiple_groups_of_examples
#define IOS std::cout.tie(0);std::cin.tie(0)->sync_with_stdio(false);
#define dbgnb(a) std::cout << #a << " = " << a << '\n';
#define dbgtt cout<<" !!!test!!! "<<endl;
#define rep(i,x,n) for(int i = x; i <= n; i++)

#define all(x) (x).begin(),(x).end()
#define pb push_back
#define vf first
#define vs second

typedef long long LL;
typedef pair<int,int> PII;

const int INF = 0x3f3f3f3f;
const int N = 2e6 + 21;
int fa[N], dep[N], siz[N], son[N], top[N], dfn[N], rnk[N];
int h[N], e[N], ne[N], w[N], dist[N], idx, p[N],cnt;
void inpfile();

void add(int u, int v) {
    e[idx] = v, ne[idx] = h[u], h[u] = idx++;
}
// 找出 fa dep siz son
void dfs1(int u) {
    // if(dep[u]) 
    son[u] = -1; // 重儿子设置为-1
    siz[u] = 1; // 当前u节点大小为1（它本身
    for(int i = h[u]; ~i; i = ne[i]) {
        int y = e[i];
        if(y == fa[u]) continue; // ** 
        if(!dep[ y]) { // 如果深度没有，则可以接着往下遍历
            dep[ y] = dep[u] + 1; // 求出深度
            fa[ y] = u; // 为y设置父亲节点
            dfs1(y); // 递归 y
            siz[u] += siz[ y]; // 当前节点u增加子节点个数
            if(son[u] == -1 || siz[ y] > siz[ son[u]]) son[u] = y; // 更新重儿子
        }
    }
}
// 求出 top dfn rnk
void dfs2(int u, int t) {

    top[u] = t; // 设置节点u的顶部节点为t
    cnt++;
    dfn[u] = cnt; // 在线段树中的编号
    rnk[cnt] = u; // DFS序对应的节点编号
    if(son[u] == -1) return ; // 如果son[u] = -1，表示是叶子节点
    dfs2(son[u], t); // 优先对重儿子进行DFS，保证同一条重链上的点DFS序连续
    for(int i = h[u]; ~i; i = ne[i]) {
        int y = e[i];
        // 当不是u的重儿子，也不是u的父亲节点
        // 那就是新的重链
        if(y != son[u] && y != fa[u]) dfs2(y, y); 
    }
}
int lca(int u, int v) {
    // 当两个点的重链顶点不一样时，表示是两个不同的重链
    // 深度大的向上跳
    // 跳到重链顶点的父亲节点
    while(top[u] != top[v]) {
        if(dep[ top[u]] > dep[ top[v]]) {
            u = fa[ top[u]];
        } else {
            v = fa[ top[v]];
        }
    }
    return dep[u] > dep[v] ? v : u;
}
void solve() {
    memset(h, -1, sizeof(h));
    int n,m,s; cin>>n>>m>>s;
    for(int i = 1; i < n; ++i) {
        int u,v; cin>>u>>v;
        add(u,v), add(v,u);
    }
    dfs1(s);
    dfs2(s,s);
    // rep(i,1,n) cout<<fa[i]<<endl;
    for(int i = 0; i < m; ++i) {
        int u,v; cin>>u>>v;
        cout<<lca(u,v)<<endl;
    }
}
int main()
{
    #ifdef Multiple_groups_of_examples
    int T; cin>>T;
    while(T--)
    #endif
    solve();
    return 0;
}
void inpfile() {
    #define mytest
    #ifdef mytest
    freopen("ANSWER.txt", "w",stdout);
    #endif
}
```



### 路径上维护

直接看代码吧，我是根据洛谷题解和oiwiki进行总结的。

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <set>
#include <map>
#include <queue>
#include <ctime>
#include <random>
#include <sstream>
#include <numeric>
#include <stdio.h>
#include <functional>
#include <bitset>
#include <algorithm>
using namespace std;

// #define Multiple_groups_of_examples
#define IOS std::cout.tie(0);std::cin.tie(0)->sync_with_stdio(false);
#define dbgnb(a) std::cout << #a << " = " << a << '\n';
#define dbgtt cout<<" !!!test!!! "<<endl;
#define rep(i,x,n) for(int i = x; i <= n; i++)

#define all(x) (x).begin(),(x).end()
#define pb push_back
#define vf first
#define vs second

typedef long long LL;
typedef pair<int,int> PII;

const int INF = 0x3f3f3f3f;
/**
 * url: https://www.luogu.com.cn/problem/solution/P3384
 * 树链剖分的思想是:对于两个不在同一重链内的节点,让他们不断地跳,使得他们处于同一重链上
 * 
 * 如何跳：
 *  用第二次dfs中记录的top数组，** x 到 top[x] 中的节点在线段树上是连续的。
 * 结合dep数组即可。
 * 
 * 选择x 和 y点dep较大的点开始跳（假设较大点是x），让x节点直接跳到 top[x]，然后在线段树上更新。
 * 最后两个节点一定是处于同一条重链的，再直接在线段树上处理即可。
 * 
 * 
*/
/* ---------------------------------------------------------------------------------------------- */
const int N = 2e6 + 21;

// - `fa(x)`：表示节点`x`在树上的父亲
// - `dep(x)`：表示节点`x`在树上的深度
// - `siz(x)`：表示节点`x`的子树的节点个数
// - `son(x)`：表示节点`x`的重儿子
// - `top(x)`：表示节点`x`所在**重链**的顶部节点（深度最小
// - `dfn(x)`：表示节点`x`的**DFS序**，也是其在线段树中的编号
// - `rnk(x)`：表示DFS序所对应的节点编号，有`rnk(dfn(x)) = x`

int fa[N], dep[N], siz[N], son[N], top[N], dfn[N], rnk[N];
int h[N], e[N], ne[N], w[N], dist[N], idx,cnt;
int p;
void inpfile();

void add(int u, int v) {
    e[idx] = v, ne[idx] = h[u], h[u] = idx++;
}
/* -------------------- 树链剖分 两次dfs -----------------------------------------------------------*/

// 找出 fa dep siz son
void dfs1(int u) {
    // if(dep[u]) 
    son[u] = -1; // 重儿子设置为-1
    siz[u] = 1; // 当前u节点大小为1（它本身
    for(int i = h[u]; ~i; i = ne[i]) {
        int y = e[i];
        if(y == fa[u]) continue; // ** 
        if(!dep[ y]) { // 如果深度没有，则可以接着往下遍历
            dep[ y] = dep[u] + 1; // 求出深度
            fa[ y] = u; // 为y设置父亲节点
            dfs1(y); // 递归 y
            siz[u] += siz[ y]; // 当前节点u增加子节点个数
            if(son[u] == -1 || siz[ y] > siz[ son[u]]) son[u] = y; // 更新重儿子
        }
    }
}

// 求出 top dfn rnk
void dfs2(int u, int t) {

    top[u] = t; // 设置节点u的顶部节点为t
    cnt++;
    dfn[u] = cnt; // 在线段树中的编号
    rnk[cnt] = u; // DFS序对应的节点编号
    if(son[u] == -1) return ; // 如果son[u] = -1，表示是叶子节点
    dfs2(son[u], t); // 优先对重儿子进行DFS，保证同一条重链上的点DFS序连续
    for(int i = h[u]; ~i; i = ne[i]) {
        int y = e[i];
        // 当不是u的重儿子，也不是u的父亲节点
        // 那就是新的重链
        if(y != son[u] && y != fa[u]) dfs2(y, y); 
    }
}

// 求lca
int lca(int u, int v) {
    // 当两个点的重链顶点不一样时，表示是两个不同的重链
    // 深度大的向上跳
    // 跳到重链顶点的父亲节点
    while(top[u] != top[v]) {
        if(dep[ top[u]] > dep[ top[v]]) {
            u = fa[ top[u]];
        } else {
            v = fa[ top[v]];
        }
    }
    return dep[u] > dep[v] ? v : u;
}

/* -------------------- 线段树 [ 区间修改 区间求和 板子 ] --------------------------------------------------*/
// （ 裸线段树：树中点映射到线段树重
struct SegTree {
    int l,r;
    LL sum, add;
}tr[N << 2];
inline int ls(int u) {return u << 1; }
inline int rs(int u) {return u << 1 | 1; }
void pushup(int u) {
    tr[u].sum = (tr[ls(u)].sum + tr[rs(u)].sum) % p;
}
void pushdown(int u) {
    auto &root = tr[u], &left = tr[ls(u)], &right = tr[rs(u)];
    if(root.add) {
        left.add += root.add; left.sum += (left.r - left.l + 1) * root.add;
        left.add %= p; left.sum %= p;
        right.add += root.add; right.sum += (right.r - right.l + 1) * root.add;
        right.add %= p; right.sum %= p;
        root.add = 0;
    }
}
void build(int u, int l, int r) {
    if(l == r) tr[u] = {l,r,w[r],0};
    else {
        tr[u] = {l,r};
        int mid = l + r >> 1;
        build(ls(u), l, mid), build(rs(u), mid + 1, r);
        pushup(u);
    }
}
void modify(int u, int l, int r, int k) {
    if(tr[u].l >= l && tr[u].r <= r) {
        tr[u].add += k;
        tr[u].add %= p;
        tr[u].sum += (tr[u].r - tr[u].l + 1) * k;
        tr[u].sum %= p;
        return ;
    }
    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    if(l <= mid) modify(ls(u),l,r,k);
    if(r > mid) modify(rs(u), l, r,k);
    pushup(u);
}
LL query(int u, int l, int r) {
    if(tr[u].l >= l && tr[u].r <= r) {
        return tr[u].sum;
    }
    int mid = tr[u].l + tr[u].r >> 1;
    LL sum = 0;
    pushdown(u);
    if(l <= mid) sum = query(ls(u), l,r);
    if(r > mid) sum += query(rs(u),l,r);
    return sum;
}
/* -------------------- 树链剖分 ------------------------------------------------------------------------*/
// 求树 从 x 到 y 结点最短路径上所有节点的值之和
LL treesum(int x, int y) {
    LL ans = 0;
    // 如果x 和 y两个点对应重链顶点不一样，就向上跳
    while(top[x] != top[y]) { 
        // 让 x 向上跳
        if(dep[ top[x]] < dep[ top[y]]) swap(x,y);
        // 查询这条重链的和
        // dfn -- 对应 树中点在线段树中的映射
        // top -- 对应重链顶点
        ans = (ans + query(1,dfn[ top[x]], dfn[x])) % p;
        // 让 x等于它重链顶点的父亲节点
        x = fa[ top[x]];
    }
    // 让 x 在左边
    if(dep[x] > dep[y]) swap(x,y);
    // 处理 x 和 y 在同一条重链的区间和
    ans = (ans + query(1, dfn[x], dfn[y])) % p;
    return ans;
}

// 将树从 x 到 y 结点 最短路径上所有节点的值都加上k
// 同上 treeadd
void treeadd(int x, int y, int k) { 
    while(top[x] != top[y]) {
        if(dep[ top[x]] < dep[ top[y]]) swap(x,y);
        modify(1, dfn[ top[x]], dfn[x], k);
        x = fa[ top[x]];
    }
    if(dep[x] > dep[y]) swap(x,y);
    modify(1, dfn[x], dfn[y], k);
}
int a[N];
void solve() {
    memset(h, -1, sizeof(h));
    int n,m,r; cin>>n>>m>>r>>p;
    for(int i = 1; i <= n; ++i) cin>>a[i];
    for(int i = 1; i < n; ++i) {
        int u,v; cin>>u>>v;
        add(u,v), add(v,u);
    }
    /* ------- dfs * 2-------------------------------------*/
    dfs1(r);
    dfs2(r,r);
    /* ------- 将对应的在线段树中的位置和值进行设置 ---------*/
    for(int i = 1; i <= n; ++i) w[ dfn[i]] = a[i];
    /* ------- 建树 ---------*/
    build(1,1,n);

    /* --------- 查询 -----------------------------------*/
    while(m--) {
        int opt; cin>>opt;
        int x,y,z;
        if(opt == 1) {
            cin>>x>>y>>z;
            treeadd(x,y,z);
        } else if(opt == 2) {
            cin>>x>>y;
            cout<<treesum(x,y) % p<<endl;
        } else if(opt == 3) {
            cin>>x>>z;
            // 以 x 为根节点的子树内所有节点值都加上z
            modify(1, dfn[x], dfn[x] + siz[x] - 1, z);

        } else {
            cin>>x;
            // 求以 x 为根节点的子树内所有的节点值之和
            cout<<query(1, dfn[x], dfn[x] + siz[x] - 1) % p<<endl;
        }
    }
}
int main()
{
    #ifdef Multiple_groups_of_examples
    int T; cin>>T;
    while(T--)
    #endif
    solve();
    return 0;
}
void inpfile() {
    #define mytest
    #ifdef mytest
    freopen("ANSWER.txt", "w",stdout);
    #endif
}
```

### 换根操作

[树链剖分（附带LCA和换根）——基于dfs序的树上优化_dazha6157的博客-CSDN博客](https://blog.csdn.net/dazha6157/article/details/101894134)

**换根对于路径上的操作并没有影响**。但是子树操作就会影响。所以需要分类讨论。

设u为要查的子树的根节点。

- 如果root = u，那么子树即为整棵树
- 设lca为root和u的LCA。如果 `lca != u`，那么对于查询没有影响
- 如果 `lca = u`，那么u节点的子树就是整棵树减去u - root这个路径上与u相挨着的节点v的子树即可。

loj AC代码

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <set>
#include <map>
#include <queue>
#include <ctime>
#include <random>
#include <sstream>
#include <numeric>
#include <stdio.h>
#include <functional>
#include <bitset>
#include <algorithm>
using namespace std;

// #define Multiple_groups_of_examples
#define IOS std::cout.tie(0);std::cin.tie(0)->sync_with_stdio(false);
#define dbgnb(a) std::cout << #a << " = " << a << '\n';
#define dbgtt cout<<" !!!test!!! "<<endl;
#define rep(i,x,n) for(int i = x; i <= n; i++)

#define all(x) (x).begin(),(x).end()
#define pb push_back
#define vf first
#define vs second

typedef long long LL;
#define int long long 
typedef pair<int,int> PII;

const int INF = 0x3f3f3f3f;
/**
 * url: https://www.luogu.com.cn/problem/solution/P3384
 * 树链剖分的思想是:对于两个不在同一重链内的节点,让他们不断地跳,使得他们处于同一重链上
 * 
 * 如何跳：
 *  用第二次dfs中记录的top数组，** x 到 top[x] 中的节点在线段树上是连续的。
 * 结合dep数组即可。
 * 
 * 选择x 和 y点dep较大的点开始跳（假设较大点是x），让x节点直接跳到 top[x]，然后在线段树上更新。
 * 最后两个节点一定是处于同一条重链的，再直接在线段树上处理即可。
 * 
 * 
*/
/* ---------------------------------------------------------------------------------------------- */
const int N = 5e5 + 21;

// - `fa(x)`：表示节点`x`在树上的父亲
// - `dep(x)`：表示节点`x`在树上的深度
// - `siz(x)`：表示节点`x`的子树的节点个数
// - `son(x)`：表示节点`x`的重儿子
// - `top(x)`：表示节点`x`所在**重链**的顶部节点（深度最小
// - `dfn(x)`：表示节点`x`的**DFS序**，也是其在线段树中的编号
// - `rnk(x)`：表示DFS序所对应的节点编号，有`rnk(dfn(x)) = x`

int fa[N], dep[N], siz[N], son[N], top[N], dfn[N], rnk[N];
int h[N], e[N], ne[N], w[N], dist[N], idx,cnt;
int p;
void inpfile();

void add(int u, int v) {
    e[idx] = v, ne[idx] = h[u], h[u] = idx++;
}
/* -------------------- 树链剖分 两次dfs -----------------------------------------------------------*/

// 找出 fa dep siz son
void dfs1(int u) {
    // if(dep[u]) 
    son[u] = -1; // 重儿子设置为-1
    siz[u] = 1; // 当前u节点大小为1（它本身
    for(int i = h[u]; ~i; i = ne[i]) {
        int y = e[i];
        if(y == fa[u]) continue; // ** 
        if(!dep[ y]) { // 如果深度没有，则可以接着往下遍历
            dep[ y] = dep[u] + 1; // 求出深度
            fa[ y] = u; // 为y设置父亲节点
            dfs1(y); // 递归 y
            siz[u] += siz[ y]; // 当前节点u增加子节点个数
            if(son[u] == -1 || siz[ y] > siz[ son[u]]) son[u] = y; // 更新重儿子
        }
    }
}

// 求出 top dfn rnk
void dfs2(int u, int t) {

    top[u] = t; // 设置节点u的顶部节点为t
    cnt++;
    dfn[u] = cnt; // 在线段树中的编号
    rnk[cnt] = u; // DFS序对应的节点编号
    if(son[u] == -1) return ; // 如果son[u] = -1，表示是叶子节点
    dfs2(son[u], t); // 优先对重儿子进行DFS，保证同一条重链上的点DFS序连续
    for(int i = h[u]; ~i; i = ne[i]) {
        int y = e[i];
        // 当不是u的重儿子，也不是u的父亲节点
        // 那就是新的重链
        if(y != son[u] && y != fa[u]) dfs2(y, y); 
    }
}

// 求lca
int lca(int u, int v) {
    // 当两个点的重链顶点不一样时，表示是两个不同的重链
    // 深度大的向上跳
    // 跳到重链顶点的父亲节点
    while(top[u] != top[v]) {
        if(dep[ top[u]] > dep[ top[v]]) {
            u = fa[ top[u]];
        } else {
            v = fa[ top[v]];
        }
    }
    return dep[u] > dep[v] ? v : u;
}

/* -------------------- 线段树 [ 区间修改 区间求和 板子 ] --------------------------------------------------*/
// （ 裸线段树：树中点映射到线段树重
struct SegTree {
    int l,r;
    LL sum, add;
}tr[N << 2];
inline int ls(int u) {return u << 1; }
inline int rs(int u) {return u << 1 | 1; }
void pushup(int u) {
    tr[u].sum = tr[ls(u)].sum + tr[rs(u)].sum;
}
void pushdown(int u) {
    auto &root = tr[u], &left = tr[ls(u)], &right = tr[rs(u)];
    if(root.add) {
        left.add += root.add; left.sum += (left.r - left.l + 1) * root.add;
        right.add += root.add; right.sum += (right.r - right.l + 1) * root.add;
        root.add = 0;
    }
}
void build(int u, int l, int r) {
    if(l == r) tr[u] = {l,r,w[r],0};
    else {
        tr[u] = {l,r};
        int mid = l + r >> 1;
        build(ls(u), l, mid), build(rs(u), mid + 1, r);
        pushup(u);
    }
}
void modify(int u, int l, int r, int k) {
    if(tr[u].l >= l && tr[u].r <= r) {
        tr[u].add += k;
        tr[u].sum += (tr[u].r - tr[u].l + 1) * k;
        return ;
    }
    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    if(l <= mid) modify(ls(u),l,r,k);
    if(r > mid) modify(rs(u), l, r,k);
    pushup(u);
}
LL query(int u, int l, int r) {
    if(tr[u].l >= l && tr[u].r <= r) {
        return tr[u].sum;
    }
    int mid = tr[u].l + tr[u].r >> 1;
    LL sum = 0;
    pushdown(u);
    if(l <= mid) sum = query(ls(u), l,r);
    if(r > mid) sum += query(rs(u),l,r);
    return sum;
}
/* -------------------- 树链剖分 ------------------------------------------------------------------------*/
// 求树 从 x 到 y 结点最短路径上所有节点的值之和
LL treesum(int x, int y) {
    LL ans = 0;
    // 如果x 和 y两个点对应重链顶点不一样，就向上跳
    while(top[x] != top[y]) { 
        // 让 x 向上跳
        if(dep[ top[x]] < dep[ top[y]]) swap(x,y);
        // 查询这条重链的和
        // dfn -- 对应 树中点在线段树中的映射
        // top -- 对应重链顶点
        ans = (ans + query(1,dfn[ top[x]], dfn[x]));
        // 让 x等于它重链顶点的父亲节点
        x = fa[ top[x]];
    }
    // 让 x 在左边
    if(dep[x] > dep[y]) swap(x,y);
    // 处理 x 和 y 在同一条重链的区间和
    ans = (ans + query(1, dfn[x], dfn[y]));
    return ans;
}

// 将树从 x 到 y 结点 最短路径上所有节点的值都加上k
// 同上 treeadd
void treeadd(int x, int y, int k) { 
    while(top[x] != top[y]) {
        if(dep[ top[x]] < dep[ top[y]]) swap(x,y);
        modify(1, dfn[ top[x]], dfn[x], k);
        x = fa[ top[x]];
    }
    if(dep[x] > dep[y]) swap(x,y);
    modify(1, dfn[x], dfn[y], k);
}
/*----------------------------- 换根操作 ------------------------------------------------------------*/
int root, n,m;
// u 到 root路径上 与u相挨着的节点v的子树
int find_adj(int u, int rt) {
    // 从深度大的开始跳，往上跳
    while(top[u] != top[rt]) {
        if(dep[ top[u]] < dep[ top[rt]]) swap(u,rt);
        // 如果 root是u所在重链的父亲节点，那么直接返回即可
        if(fa[ top[u]] == rt) return top[u];
        u = fa[ top[u]];
    }
    // 让root深度最浅
    if(dep[u] < dep[rt]) swap(u, rt);
    return son[rt];
}


// 设u为要查的子树的根节点。
// - 如果root = u，那么子树即为整棵树
// - 设lca为root和u的LCA。如果 `lca != u`，那么对于查询没有影响
// - 如果 `lca = u`，那么u节点的子树就是整棵树减去u - root这个路径上与u相挨着的节点v的子树即可。
void nodeadd(int u, int k) {
    if(root == u) modify(1,1,n, k); // 子树就是整树
    else {
        int lac = lca(u, root);
        if(lac != u) modify(1, dfn[u], dfn[u] + siz[u] - 1, k); // 对查询没有影响
        else {
            // 否则就是  u节点的子树就是整棵树减去u - root这个路径上与u相挨着的节点v的子树
            int adju = find_adj(u, root);
            modify(1,1,n, k);
          modify(1, dfn[adju], dfn[adju] + siz[adju] - 1, -k);
        }
    }
}
// 同上
LL nodesum(int u) {
    if(root == u) return query(1,1,n);
    else {
        int lac = lca(u, root);
        if(lac != u) return query(1, dfn[u], dfn[u] + siz[u] - 1);
        else {
            int adju = find_adj(u, root);
            return query(1, 1,n) - query(1, dfn[adju], dfn[adju] + siz[adju] - 1);
        }
    }
}
int a[N];
void solve() {
    memset(h, -1, sizeof(h));
    cin>>n;
    root = 1;
    for(int i = 1; i <= n; ++i) cin>>a[i];
    for(int i = 1; i < n; ++i) {
        int u; cin>>u;
        add(u,i+1); add(i+1,u);
    }
    // cin>>m;
    // dbgtt
    /* ------- dfs * 2-------------------------------------*/
    dfs1(1);
    dfs2(1,1);
    /* ------- 将对应的在线段树中的位置和值进行设置 ---------*/
    for(int i = 1; i <= n; ++i) w[ dfn[i]] = a[i];
    // for(int i = 1; i <= n; ++i) cout<<dfn[i]<<endl;
    /* ------- 建树 ---------*/
    build(1,1,n);
    /* --------- 查询 -----------------------------------*/
    cin>>m;
    while(m--) {
        int opt; cin>>opt;
        int x,y,z;
        if(opt == 1) {
            cin>>x;
            root = x;
        } else if(opt == 2) {
            cin>>x>>y>>z;
            treeadd(x,y,z);
        } else if(opt == 3) {
            cin>>x>>z;
            nodeadd(x,z);
        } else if(opt == 4) {
            cin>>x>>y;
            cout<<treesum(x,y)<<endl;
        } else {
            cin>>x; 
            cout<<nodesum(x)<<endl;
        }
    }
}
signed main()
{
    #ifdef Multiple_groups_of_examples
    int T; cin>>T;
    while(T--)
    #endif
    solve();
    return 0;
}
void inpfile() {
    #define mytest
    #ifdef mytest
    freopen("ANSWER.txt", "w",stdout);
    #endif
}
```

**WA的原因**：

1. 用的是洛谷的树链剖分代码，洛谷有**模数**，这个模板没有。模数为0，程序自动结束了，找了俩小时bug。
2. 变量太多，变量相似且代码空格少，导致对代码容易眼花，找不到错误。而且几个函数还相似（都不想看

### 换根后找lca

```cpp
// https://www.luogu.com.cn/blog/Farkas/guan-yu-shu-lian-pou-fen-huan-gen-cao-zuo-bi-ji
int LCA(int x, int y) {
    if(dep[x] > dep[y]) swap(x,y);
    int xr = lca(x,root), yr = lca(y,root), xy = lca(x,y);
    if(xy == x) { // 当 lca(x,y) == x时
        if(xr == x) {
            // 情况1：root 在x的子树中，也在y的子树中，即
                // lca(x,root) == x && lca(y,root) == y 此时 LCA(x,y)是y
            if(yr == y) return y;
            // 情况2：root在x的子树中，但不在y的子树中，即lca(x,root)，此时 LCA(x,y) 是 lca(y,root)
            return yr;
        }
        // 情况3：是x
        return x;
    }
    if(xr == x) {
        return x;
    }
    if(yr == y) {
        return y;
    }
    if(xr == root && xy == yr || (yr == root && xy == xy)) {
        return root;
    }
    if(xr == yr) return xy;
    if(xy != xr) return xr;
    return yr;
}
```





[树链剖分详解（洛谷模板 P3384） - ChinHhh - 博客园 (cnblogs.com)](https://www.cnblogs.com/chinhhh/p/7965433.html)

[浅谈树链剖分 "换根操作" - Farkas_W的博客 - 洛谷博客 (luogu.com.cn)](https://www.luogu.com.cn/blog/Farkas/guan-yu-shu-lian-pou-fen-huan-gen-cao-zuo-bi-ji)

[树链剖分（附带LCA和换根）——基于dfs序的树上优化_dazha6157的博客-CSDN博客](https://blog.csdn.net/dazha6157/article/details/101894134)