### 本题思路

一维bfs。

### 代码

```cpp
void solve() {
    int n,A,B; cin>>n>>A>>B; // 读入
    vector<int> ph(n+1);
    auto f(ph);
    for(int i = 1; i <= n; ++i) cin>>ph[i];
    int mi = INF;
    vector<int> fxy({1,-1}); // 一维方向，向上，向下
    if(A == B) { // 特判，初始时A是否等于B，等于输入0，结束
        cout<<"0";
        return ;
    }
    queue<PII> q; q.push({A,0}); // <当前层数，用的次数>
    while(q.size()) { // bfs模板
        auto t = q.front(); q.pop();
        for(int i = 0; i < 2; ++i) { // 两个方向
            int xy = t.vf + fxy[i] * ph[t.vf];
            if(xy < 1 || xy > n) continue; // 如果不满足电梯层数要求，continue
            if(f[xy]) continue; // 如果该层已经访问过
            f[xy] = 1; // 置1
            if(xy == B) { // 当前层数等于B，
                mi = min(mi, t.vs + 1);
            }
            q.push({xy, t.vs + 1});
        }
    }
    if(mi == INF) mi = -1; // 如果没有找到，返回-1
    cout<<mi;
}
```

