[2023第四场多校]([牛客竞赛_ACM/NOI/CSP/CCPC/ICPC算法编程高难度练习赛_牛客竞赛OJ (nowcoder.com)](https://ac.nowcoder.com/acm/contest/57358))

### A

给定字符串t，和字符串s的长度，问经过`t + s + t`编码后是否可以接收成功。注意：字符串t可以被覆盖 e.g. `0101010` ，t为`0101`，被覆盖了。

赛时思路：

​	全0/1，判断一下就行，后来发现特例，`10010`，本应该是全0的，但是全0错误。之后用前缀函数搞过了。

题解：

​	找到全0/1后，暴力，KMP，hash找个数就行。

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <set>
#include <map>
#include <queue>
#include <ctime>
#include <random>
#include <sstream>
#include <numeric>
#include <stdio.h>
#include <algorithm>
using namespace std;

#define Multiple_groups_of_examples
#define IOS std::cout.tie(0);std::cin.tie(0)->sync_with_stdio(false);
#define dbgnb(a) std::cout << #a << " = " << a << '\n';
#define dbgtt cout<<" !!!test!!! "<<endl;
#define rep(i,x,n) for(int i = x; i <= n; i++)

#define all(x) (x).begin(),(x).end()
#define vf first
#define vs second

typedef long long LL;
typedef pair<int,int> PII;

const int INF = 0x3f3f3f3f;
const int N = 2e5 + 21;
typedef unsigned long long ULL;

class strHash {
	typedef unsigned long long ULL;
public:
	strHash(const string& s) {
		this->str = "^" + s;
		dispose();
	}
	ULL get(int l, int r) {
		return h[r] - h[l - 1] * p[r - l + 1];
	}
private:
	void dispose() {
		len = str.size();
		h.assign(len + 1, 0); p.assign(len + 1, 0);
		h[0] = p[0] = 1;
		for(int i = 1; i <= len; ++i) {
			h[i] = h[i-1] * P + str[i];
			p[i] = p[i - 1] * P;
		}
	}

	const ULL P = 11451;
	string str;
	ULL len;
	vector<ULL> h,p;
};

void inpfile();
void solve() {
    int n; cin>>n;
    string str; cin>>str;
    string s = str;
    int a = 1;
    rep(i,1,n) s += '1';
    s += str;
    int len = s.size();
    strHash hs1(s), hs2(str);
    ULL ak = hs2.get(1,str.size());
    int strlen = str.size();
    int cnt = 0;
    rep(i,1,len - strlen+1) {
        if(hs1.get(i, i + strlen-1) == ak) cnt++;
    }
    if(cnt > 2) a = 0;
    rep(i,1,n) cout<<a; puts("");
}
int main()
{
    #ifdef Multiple_groups_of_examples
    int T; cin>>T;
    while(T--)
    #endif
    solve();
    return 0;
}
void inpfile() {
    #define mytest
    #ifdef mytest
    freopen("ANSWER.txt", "w",stdout);
    #endif
}
```



### F

题意又臭又长。

赛时思路：

​	队友写的。

赛后：

双端队列，deque，判断中间值，进行pop front/back

```cpp
void solve() {
    int n; cin>>n;
    deque<PII> a(n);
    for(int i = 0; i < n; ++i) {
        cin>>a[i].vf;
        a[i].vs = i;
    }
    sort(all(a), [](PII pre, PII suf) {
        if(pre.vf != suf.vf) return pre.vf < suf.vf;
        return pre.vs < suf.vs;
    });
    while(n > 1) {
        int left = 0, right = 0;
        int leftval = a[0].vf, rightval = a[n-1].vf;
        for(int i = 1; i < n-1; ++i) {
            if(abs(a[i].vf - leftval) > abs(a[i].vf - rightval)) {
                left++;
            }else right++;
        }
        if(left <= right) a.pop_back();
        else a.pop_front();
        --n;
    }
    cout<<a.front().vs + 1;
}
```

### H

给定n，问边长为n的正方形能不能被分为2到50个小正方形组成的。如果可以输出个数，和每个点、长度等。

赛时：

​	数学

题解：

​	dfs，先预处理`n * m`长度的矩形可以被分成多少个正方形。之后dfs一边即可。

```cpp
int get(int a, int b) { // 找到 a行b列时，可以向下分多少个小正方形
    return b == 0 ? 0 : a / b + get(b, a % b);
}
void solve() {
    int n; cin>>n;
    vector<int> f(n+1);
    for(int i = 2; i <= n; ++i) { // 预处理
        for(int j = 1; j < i; ++j) {
            if(2 + 2 * get(i, i - j) <= 50) {
                f[i] = j;
                break;
            }
        }
    }
    vector<adt> ans;
    auto dfs = [&](auto &&dfs, int x1, int y1, int x2, int y2) -> void {
        if(x2 - x1 == y2 - y1) { // 如果相同，dfs4个小正方形
            if(x2 - x1 == 1) {
                return ;
            }
            int k = f[x2 - x1]; // 找到小于50个正方形时的边长长度
            dfs(dfs, x1,y1, x1 + k, y1 + k);
            dfs(dfs, x1+k, y1 + k, x2, y2);
            dfs(dfs, x1, y1 + k, x1 + k, y2);
            dfs(dfs, x1 + k, y1, x2, y1 + k);
            ans.push_back({x1,y1,x2 - x1});
            return ;
        } else if(x2 - x1 < y2 - y1) { // 如果当前不是正方形，则向下分正方形和矩形，不记录
            int k = x2 - x1;
            dfs(dfs, x1, y1, x1 + k, y1 + k);
            dfs(dfs, x1, y1 + k, x2, y2);
            // ans.push_back({x1,y1,k});
        } else {
            int k = y2 - y1;
            dfs(dfs, x1, y1, x1 + k, y1 + k);
            dfs(dfs, x1 + k, y1, x2, y2);
            // ans.push_back({x1,y1,k});
        }
    };
    // dbgtt
    dfs(dfs,0,0,n,n);
    // dbgtt 
    cout<<ans.size()<<endl;
    for(auto t: ans) {
        cout<<t.x + 1<<" "<<t.y + 1<<" "<< t.k<<endl;
    }
}
```

### L

`n * m`的矩形，每次可以对一行或一列进行开关灯操作（初始为关），问最后有多少个灯亮着。

赛时：

​	队友写出的

题解：

​	正难则反，反向模拟，可以消除每次操作对之后的影响。

```cpp
struct adt {
    int val,type, st;
    // val 行或列的值，type 行还是列 1 -- 行， 0 -- 列，st 是否开灯， 1 -- 开灯 0 -- 关灯
};
void inpfile();
void solve() {
    int n,m; cin>>n>>m;
    int q; cin>>q;
    vector<adt> vi;
    vector<int> row(n+1), col(m+1);
    for(int i = 0; i < q; ++i) {
        string what,sta; int a; cin>>what>>a>>sta;
        if(sta == "on") {
            if(what == "row") vi.push_back({a, 1, 1});
            else vi.push_back({a, 0, 1});
        } else {
            if(what == "row") vi.push_back({a,1,0});
            else vi.push_back({a,0,0});
        }
    }
    int len = vi.size();
    LL ans = 0;
    for(int i = len-1; i >= 0; --i) {
        if(vi[i].st) {
            // 开灯
            if(vi[i].type == 1) {
                // 行
                if(row[vi[i].val]) continue;
                row[vi[i].val] = 1;
                ans += m;
                n--;
            } else {
                if(col[vi[i].val]) continue;
                col[vi[i].val] = 1;
                ans += n;
                m--;
            }
        } else {
            // 关灯
            if(vi[i].type == 1) {
                if(row[vi[i].val]) continue;
                row[vi[i].val] = 1;
                n--;
            } else {
                if(col[vi[i].val]) continue;
                col[vi[i].val] = 1;
                m--;
            }
        } 
    }
    cout<<ans;
}
```

## 总结

思维不行，要多练。正难则反，反向模拟。这也可以dfs，搜索做的少了。多练。