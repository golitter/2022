[Dashboard - Codeforces Round 904 (Div. 2) - Codeforces](https://codeforces.com/contest/1884)

A题，k最多是10，遍历几十次就可以。

```cpp
void solve() {
    int x,k; cin>>x>>k;
    auto get = [&](int res) -> int {
        int rt = 0;
        while(res) {
            rt += res % 10;
            res /= 10;
        }
        return rt;
    };
    while(x) {
        if(get(x) % k == 0) {
            cout<<x<<'\n';
            return ;
        }
        x++;
    }
}
```

B题，贪心，从后往前，每次移动占用一个前缀0。细节挺多。

```cpp
void solve() {
    int n; cin>>n;
    string s; cin>>s;
    vector<int> cnt1(n + 1);
    int cnt0 = 0;
    for(int i = n-1; i >= 0; --i) {
        if(s[i] == '1') {
            for(int j = 0; j < i; ++j) {
                cnt0 += s[j] == '0';
            }
            break;
        }
    }
    int tp = 0;
    for(int i = 0; i < n; ++i) {
        if(s[i] == '1') tp++;
        else if(i != 0) cnt1[i-1] = tp, tp = 0;
    }
    if(tp) cnt1[n-1] = tp,tp = 0;
    int now = 0,k = n;
    for(int i = n-1; i >= 0; --i) {
        if(cnt1[i] == 0) {
            --k;
            cout<<now<<" ";
        } else {
            if(cnt0 <= 0) break;
            --k;
            now += cnt1[i];   
            cnt0--;
            cout<<now<<" ";
            int l = i - cnt1[i] - 1;
            if(l >= 1 && cnt1[l] > 0 && i > 0) cnt1[i-1] = cnt1[i] + cnt1[l], s[i-1] = '1',cnt1[l] = 0;
            else if(i > 0) cnt1[i-1] = cnt1[i];
        }
    }
    while(k--) {
        cout<<-1<<" ";
    }
    puts("");

}
```

C题，离散前缀和，用map即可。

如果所有的线段覆盖的位置都无法包含 111 到 mmm 中的某个点，那么最小值是固定的，即为 000 ，直接选中所有线段最优。如果所有的点都被这 nnn 条线段覆盖了，那么可以选择将覆盖两端（ 111 和 mmm ）中的一端的所有线段移除，这样最小值变为 000 ，且最大值与最小值之差不会变小，所以讨论一下移除两端线段的情况下能达到的最大值即可

```cpp
void solve() {
    int n,m; cin>>n>>m;
    vector<array<int,4>> seg(n);
    map<int,int> mp;
    for(auto &t: seg) {
        cin>>t[0]>>t[1];
        if(t[0] == 1) t[2] = 1;
        if(t[1] == m) t[3] = 1;
        mp[t[0]]++;
        mp[t[1] + 1]--;
    }
    sort(all(seg), [&](array<int,4> pre, array<int,4> suf) {
        return pre[0] < suf[0];
    });
    vector<array<int,2>> last;
    last.push_back({seg[0][0], seg[0][1]});
    int mi = INF;
    for(int i = 1; i < n; ++i) {
        if(last.back()[1] >= seg[i][0]) last.back()[1] = max(last.back()[1], seg[i][1]);
        else last.push_back({seg[i][0], seg[i][1]});
    }
    if(last.size() > 1 || last[0][0] > 1 || last[0][1] < m) mi = 0;
    int now = 0, ans = 0;
    for(auto &t: mp) {
        now += t.vs;
        ans = max(ans, now);
    }
    if(mi != INF) {
    } else {
        mp.clear();
        now = 0;
        ans = 0;
        for(auto &t: seg) {
            if(t[2]) continue;
            mp[t[0]]++;
            mp[t[1] + 1]--;
        }
        for(auto &t: mp) {
            now += t.vs;
            ans = max(ans, now);
        }
        mp.clear();
        now = 0;
        int tmp = 0;
        for(auto &t: seg) {
            if(t[3]) continue;
            mp[t[0]]++;
            mp[t[1] + 1]--;
        }
        for(auto &t: mp) {
            now += t.vs;
            tmp = max(tmp, now);
        }
        ans = max(ans, tmp);
    }
    cout<<ans<<endl;
}
```

