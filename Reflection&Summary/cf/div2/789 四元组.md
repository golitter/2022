[Dashboard - Codeforces Round 789 (Div. 2) - Codeforces](https://codeforces.com/contest/1678)



A题，找最小次数将数组元素全为0.

```cpp
void solve() {
    int n; cin>>n;
    vector<int> a(n);
    for(auto &t: a) cin>>t;
    sort(all(a));
    int ans = 0;
    if(a[0] == 0) {
        int cnt = 0;
        for(auto t: a) {
            if(t != 0) break;
            cnt++;
        }
        ans = n - cnt;
    } else {
        a.erase(unique(all(a)), a.end());
        if(n == a.size()) ans = n + 1;
        else ans = n;
    }
    cout<<ans<<endl;
}
```

B题，all偶数段0或1段，求最少的操作次数将0/1翻转1/0和最少操作次数得到的0或1段的段数。

```cpp
void solve() {
    int n; cin>>n;
    string s; cin>>s;
    int cnt = 0;
    string t = "";
    for(int i = 1; i < n; i += 2) {
        if(s[i] != s[i-1]) {
            cnt++;
        } else t += s[i-1], t += s[i];
    }
    int ans = 1;
    int len = t.size();
    char ch = t[0];
    for(int i = 1; i < len; ++i) if(ch != t[i]) ans++, ch = t[i];
    cout<<cnt<<" "<<ans<<endl;
}
```

C题，一个经典的区间乱操作。

找满足`1 <= a < b < c < d`，且`pa < pc && pb > pd`。

这个朴素的时间复杂度是`O(n ** 4)`的，如果可能枚举两个什么的，时间复杂降至`O(n ** 2)`，那么就能通过这题了。发现，枚举b和c，根据所给条件可以找满足条件的a和d。又因为是排列，不超过5000，可以预处理出前i个数中小于等于j的个数，此题结束。

```cpp
/**
 * 问题转换为：在 [1, b - 1]内有多少个数小于p[c]，在[c + 1, n]内有多少个数是小于p[b]
 * sum[i][j]：表示前i个数中小于等于j的个数
 * 前i-1个数中，小于j的数也一定满足在前i个数小于j
*/
void inpfile();
void solve() {
    int n; cin>>n;
    vector<int> a(n + 1);
    for(int i = 1; i <= n; ++i) cin>>a[i];
    vector<vector<int>> sum(n + 1, vector<int>(n + 1));
    for(int i = 1; i <= n; ++i) {
        sum[i] = sum[i-1];
        for(int j = a[i]; j <= n; ++j) sum[i][j]++;
    }
    int ans = 0;
    for(int b = 1; b <= n; ++b) {
        for(int c = b + 1; c <= n; ++c) {
            ans += sum[b-1][a[c]-1] * (sum[n][a[b]] - sum[c][a[b]]);
        }
    }
    cout<<ans<<endl;
}
```

另一个四元组问题：

[Problem - D - Codeforces](https://codeforces.com/contest/1400/problem/D)

```cpp
void solve() {
    int n; cin>>n;
    vector<int> a(n + 1);
    for(int i = 1; i <= n; ++i) cin>>a[i];
    vector<vector<int>> sum(n + 1, vector<int> (n  + 1));
    for(int i = 1; i <= n; ++i) {
        sum[i] = sum[i-1];
        for(int j = i; j <= n; ++j) sum[j][a[i]]++;
    }
    int ans = 0;
    for(int j = 1; j <= n; ++j) {
        for(int k = j + 1; k <= n; ++k) {
            ans += sum[j-1][a[k]] * (sum[n][a[j]] - sum[k][a[j]]);
        }
    }
    cout<<ans<<endl;
}
```

> 四元组问题，枚举两个，根据条件并根据选择的两个去找剩下两个

