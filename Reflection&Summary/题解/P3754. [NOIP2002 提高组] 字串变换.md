### 本题思路

纯bfs，注意一个字符中有多个相同的可变字符即可。

### 代码

```cpp
void solve() {
    string a,b; cin>>a>>b; // 读入起始串和结束串
    vector<pair<string,string>> mss; // 可能有一个字符串的多个变换规则，不能用map，multimap可以（应该
    string p,qq;
    while(cin>>p>>qq) { // 读入规则
        mss.push_back({p,qq});
    }
    set<string> s; // 用一个集合进行判断，是否之前存在这种字符串
    int mi = INF; // 所求最小值
    bool fg = false; // 判断是否找到解
    s.insert(a); // 先将起始串存入
    queue<pair<string, int>> q; // 队列 --- < 字符串， 已经变换次数>
    q.push({a,0}); 
    while(q.size()) { // bfs模板
        auto tmp = q.front(); q.pop();
        if(tmp.vs > 10) continue; // 如果大于10次操作，直接continue
        for(auto t: mss) { // 根据规则进行变换
            string str = tmp.vf; // 上一个已经变换的字符串
            int pos = str.find(t.vf); // 找到该字符串中是否有相应的变换规则
            // 注意： find()函数返回为size_t类型，是ull类型，可能溢出，用int可以进行隐式转换
            if(pos == -1) continue; // 如果没有，find函数返回-1，则continue
            int len = str.size(); // 上一个字符串的长度

            while(pos != -1 && pos < len) { // 可能有多个可以进行相应变换的字符串
                // e.g.  abaaaa 变换规则： a -> b, a -> c, a -> dd等

            string now = ""; // 用now作为当前变换过的字符串
            for(int i = 0; i < pos; ++i) {
                now += str[i]; // 
            }
            now += t.vs;
            pos += t.vf.size();
            for(int i = pos; i < str.size(); ++i) {
                now += str[i];
            }
            // 上面是进行转换

            if(s.count(now) == 0) { // 判断是否已经存在
                s.insert(now);
                q.push({now, tmp.vs + 1});
            }
            if(now == b) { // 判断是否等于目标串
                mi = min(mi, tmp.vs + 1);
                fg = true;
            } 
            pos = str.find(t.vf, pos);
            // cout<<pos<<endl;
            }
        }
        if(fg) break; // 如果找到了，可以直接break，否则可能会超时
    }
    if(mi > 10) puts("NO ANSWER!");
    else cout<<mi;
}
```

