## 树状数组 离线处理



![image-20230816225324840](https://cdn.789ak.com/img/image-20230816225324840.png)



> [树状数组（求区间种类数 离线处理___Rain的博客-CSDN博客](https://blog.csdn.net/cosx_/article/details/120578080?ops_request_misc=&request_id=&biz_id=102&utm_term=树状数组 离线处理&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-120578080.142^v92^insert_down1&spm=1018.2226.3001.4187)



[P4113 [HEOI2012\] 采花 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4113)

问题描述：略。

思路：按左右端点进行排序，记录右左上一次出现的下标和上上次出现的下标，处理成前缀和，跑树状数组。

代码：

```cpp
const int INF = 0x3f3f3f3f;
const int N = 2e6 + 21;
int n,m,c;
int tr[N];
int lowbit(int x) {
    return x & -x;
}
void add(int x, int c) {
    if(!x) return ; // 注意：可能x为0，这时候是死循环，半小时才调出来（
    for(; x <= n; x += lowbit(x)) tr[x] += c;
}
int query(int x) {
    int res = 0;
    for(; x; x -= lowbit(x)) res += tr[x];
    return res;
}
// pre -- 下一次出现的相同颜色的下标
// color -- 颜色映射
// a -- 读入的颜色
// ans -- 存答案
int pre[N],color[N], a[N];
int ans[N];
inline int fread() // 快读
{
    int x = 0, f = 1; char ch = getchar();
    while(ch < '0' || ch > '9') {if (ch == '-') f = -1; ch = getchar(); }
    while(ch >= '0' && ch <= '9') {
        x = x * 10 + (ch - '0');
        ch = getchar();
    }
    return x * f;
}
void inpfile();
void solve() {
    // int n,c,m; 
    n = fread(), c = fread(), m = fread();
    rep(i,1,n) {
        // cin>>a[i];
        /**
         * 将pre[i] 指向上一个出现相同颜色的下标
         * color[a[i]] = i 表示将这个颜色的最近的下标进行更改
        */
        a[i] = fread();
        pre[i] = color[a[i]];
        color[a[i]] = i;
    }
    vector<array<int,3>> lit(m + 1); // l, r 存入顺序
    rep(i,1,m) {
        // cin>>lit[i][0]>>lit[i][1];
        lit[i][0] = fread();
        lit[i][1] = fread();
        lit[i][2] = i;
    }
    sort(lit.begin() + 1, lit.end(), [](array<int,3> pre, array<int,3> suf) {
        return pre[1] < suf[1]; // 对右端点进行排序
    });
    for(int i = 1, j = 1; i <= n; ++i) {
        add(pre[i], 1); // 将上次出现相同颜色的加1
        add(pre[pre[i]], -1); // 将上上次出现相同颜色的-1，（相当于去重了
            // e.g.     4 4 4 4 4 4  => (1,5)
        while(j <= m && lit[j][1] == i) { // 如果i等于右端点，表示可以得到答案
            ans[ lit[j][2]] = query(lit[j][1]) - query(lit[j][0] - 1);
            ++j;
        }
        if(j > m) break;
    }
    rep(i,1,m) printf("%d\n",ans[i]);
}
```

[P1972 [SDOI2009\] HH的项链 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1972)

问题描述：略。

思路：跟采花一样。

```cpp
// 改动
        add(i, 1); // 将上次出现相同颜色的加1
        add(pre[i], -1); // 将上上次出现相同颜色的-1，（相当于去重了
```

代码：

```cpp
typedef long long LL;
typedef pair<int,int> PII;

const int INF = 0x3f3f3f3f;
const int N = 2e6 + 21;
int n,m,c;
int tr[N];
int lowbit(int x) {
    return x & -x;
}
void add(int x, int c) {
    if(!x) return ; // 注意：可能x为0，这时候是死循环，半小时才调出来（
    for(; x <= n; x += lowbit(x)) tr[x] += c;
}
int query(int x) {
    int res = 0;
    for(; x; x -= lowbit(x)) res += tr[x];
    return res;
}
// pre -- 下一次出现的相同颜色的下标
// color -- 颜色映射
// a -- 读入的颜色
// ans -- 存答案
int pre[N],color[N], a[N];
int ans[N];
inline int fread() // 快读
{
    int x = 0, f = 1; char ch = getchar();
    while(ch < '0' || ch > '9') {if (ch == '-') f = -1; ch = getchar(); }
    while(ch >= '0' && ch <= '9') {
        x = x * 10 + (ch - '0');
        ch = getchar();
    }
    return x * f;
}
void inpfile();
void solve() {
    // int n,c,m; 
    n = fread(); // m = fread();
    rep(i,1,n) {
        // cin>>a[i];
        /**
         * 将pre[i] 指向上一个出现相同颜色的下标
         * color[a[i]] = i 表示将这个颜色的最近的下标进行更改
        */
        a[i] = fread();
        pre[i] = color[a[i]];
        color[a[i]] = i;
    }
    m = fread();
    vector<array<int,3>> lit(m + 1); // l, r 存入顺序
    rep(i,1,m) {
        // cin>>lit[i][0]>>lit[i][1];
        lit[i][0] = fread();
        lit[i][1] = fread();
        lit[i][2] = i;
    }
    sort(lit.begin() + 1, lit.end(), [](array<int,3> pre, array<int,3> suf) {
        return pre[1] < suf[1]; // 对右端点进行排序
    });
    for(int i = 1, j = 1; i <= n; ++i) {
        add(i, 1); // 将上次出现相同颜色的加1
        add(pre[i], -1); // 将上上次出现相同颜色的-1，（相当于去重了
            // e.g.     4 4 4 4 4 4  => (1,5)
        while(j <= m && lit[j][1] == i) { // 如果i等于右端点，表示可以得到答案
            ans[ lit[j][2]] = query(lit[j][1]) - query(lit[j][0] - 1);
            ++j;
        }
        if(j > m) break;
    }
    rep(i,1,m) printf("%d\n",ans[i]);
}
```

[换个角度思考 (nowcoder.com)](https://ac.nowcoder.com/acm/problem/19427)

问题描述：略。

思路：对a进行排序，对k进行排序。树状数组 离线处理。

代码：

```cpp
const int INF = 0x3f3f3f3f;
const int N = 2e5 + 21;
int tr[N];
int lowbit(int x) {
    return x & -x;
}
void add(int x, int c) {
    if(!x) return ;
    for(; x < N; x += lowbit(x)) tr[x] += c;
}
int query(int x) {
    int res = 0;
    for(; x; x -= lowbit(x)) res += tr[x];
    return res;
}
PII a[N];
int ans[N];
void inpfile();
void solve() {
    int n,m; cin>>n>>m;
    rep(i,1,n) {
        cin>>a[i].vf;
        a[i].vs = i;
    }
    vector<array<int,4>> lit(m + 1); // lit
    for(int i = 1; i <= m; ++i) {
        cin>>lit[i][0]>>lit[i][1]>>lit[i][2];
        lit[i][3] = i;
    }
    sort(a+1, a+n+1, [](PII pre, PII suf) {
        return pre.vf < suf.vf;
    });
    sort(lit.begin() + 1, lit.end(), [](array<int,4> pre, array<int,4> suf) {
        return pre[2] < suf[2];
    });
    for(int i = 1, j = 1; i <= m; ++i) {
        int sit = lit[i][3];
        int val = lit[i][2];
        while(j <= n && a[j].vf <= val) {
            add(a[j].vs, 1);
            // cout<<a[j].vf<<" "<<val<<endl;
            ++j;
        }
        ans[ sit] = query(lit[i][1]) - query(lit[i][0] - 1);
    }
    rep(i,1,m) cout<<ans[i]<<endl;
}
```





[hdu 3874 树状数组 离线处理_xiaohuihuicb的博客-CSDN博客](https://blog.csdn.net/sinat_30062549/article/details/52064798?ops_request_misc=&request_id=&biz_id=102&utm_term=树状数组 离线处理&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-52064798.nonecase&spm=1018.2226.3001.4187)

[（树状数组+离散化+离线处理）_搬砖的小孩有肉吃的博客-CSDN博客](https://blog.csdn.net/qq_43746332/article/details/98586088?ops_request_misc=&request_id=&biz_id=102&utm_term=树状数组 离线处理&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-98586088.nonecase&spm=1018.2226.3001.4187)