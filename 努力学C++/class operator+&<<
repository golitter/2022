/**
 * @file learnlab.cpp
 * @author your name (you@domain.com)
 * @brief 
 * @version 0.1
 * @date 2022-06-29
 * 
 * IPDT:
 * 	运算符重载;
 * // 总结：对于内置的数据类型的表达式的运算符是不可能更改的；
 * // 总结： 不要滥用运算符重载;
 * 
 * 左移运算符;
 * 
 * 
 * 递增运算符:
 * @copyright Copyright (c) 2022
 * 
 */

#include <iostream>
#include <vector>
#include <string>
#include <set>
#include <algorithm>
using namespace std;

class Person {
	friend Person operator+ (Person &a, int num);
	friend Person operator+ (Person &a, Person &b);
	friend ostream& operator<<(ostream &cout, Person &p);
public:
	Person (int a, int b): m_A(a), m_B(b) {;}
private:
	int m_A;
	int m_B;
	// 1, 成员函数重载+号;

	// 本质: Person p3 = p1.operator+(p2);

	// Person operator+(Person& p) {
	// 	Person temp;
	// 	temp.m_A = this->m_A + p.m_A;
	// 	temp.m_B = this->m_B + p.m_B;
	// 	return temp;
	// }

	// operator<<
	//void operator<< {}
	// 不会利用成员函数重载<<运算符，因为无法实现cout在左侧； like cout<<p / but this is p<<cout so error;

};
// 2,全局函数重载+号;

// 本质： Person p3 = operator+(p1, p2);
Person operator+ (Person &a, Person &b) {
	Person temp(0,0);
	temp.m_A = a.m_A + b.m_A;
	temp.m_B = a.m_B + b.m_B;
	return temp;
}

// 函数重载版本;
Person operator+ (Person &a, int num) {
	Person temp(0,0);
	temp.m_A = a.m_A + num;
	temp.m_B = a.m_B + num;
	return temp;
}

// operator<< 只能利用全局函数重载左移运算符;
// & out -- > cout;
// AND: ostream only one;
ostream& operator<< (ostream &cout,Person &p) { // 本质operator<<(cout, p) --> cout<<p;
	cout<<"m_A :"<<p.m_A<<" m_B :"<<p.m_B<<endl;
	return cout;
}
void test1() {
	// Person a,b;
	// a.m_A = 1000,a.m_B = 10000;
	// b.m_A = 3,b.m_B = 233;
	// Person c = a+b;
	// cout<<c.m_A<<" "<<c.m_B<<endl;
	// int num = 1232323;
	// Person d = c + num;
	// cout<<d.m_A<<" "<<d.m_B<<endl;
}
void test2() {
	Person a(3434324,343245435);
	cout<<a;
}
int main()
{
	test2();
	return 0;
}
