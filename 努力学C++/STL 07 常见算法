#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <ctime>
using namespace std;
void Print(int val) {
    cout<<val<<" ";
}
class print02 {
public:
    void operator() (int val) {
        cout<<val<<" ";
    } 

};
class Trfr{
public:
    int operator()(int a) {
        return a*10;
    }
};
class Person {
public:
    Person(string name, int age) {
        this->m_name = name;
        this->m_age = age;
    }
    // 重载 == 让底层find知道如何对比Person数据类型
        // NOTICE： const
    bool operator== (const Person &p) {
        if(this->m_name == p.m_name && this->m_age == p.m_age) {
            return true;
        } else {
            return false;
        }
    }
    string m_name;
    int m_age;
};
class BB{
public:
    bool operator() (int val) {
        return val > 5;
    }
};
class CP{
public:
    bool operator() (Person &p) {
        return p.m_age > 20;
    }
};
void test() {
    // 常用遍历函数 for_each very important
    // 普通函数不用括号，仿函数要加括号
    vector<int> v;
    for(int i = 0; i < 10; ++i) v.push_back(i);
    for_each(v.begin(), v.end(),Print); puts("");
    for_each(v.begin(), v.end(), print02());
    // transform --->  transform(iterator1.1, iterator1.2, iterator2.1, Func);
    // NOTICE: 必须提前开辟空间
    // transform(v.begin(), v.end(), v.begin(), ::toupper / :: tolower);;;;;;;;;;;;;
    vector<int> vTarget;
    puts("");
    vTarget.resize(v.size());
    transform(v.begin(), v.end(), vTarget.begin(), Trfr());
    for_each(vTarget.begin(), vTarget.end(), print02());
    
    // 常用查找函数
        // find 找不到返回迭代器;
        int nums[] = {1,2,3,4};
        cout<<find(nums+0, nums+4,5) - nums;
        puts("");
        vector<int> var;
        for(int i = 0; i <10; ++i) var.push_back(i);
        // 容器中 是否有 五 这个元素
        auto pos = find(var.begin(),var.end(),5);
        if(pos == var.end()) puts("NO FIND");
        else puts("FIND");
        vector<Person> vp;
        Person p1("golitter",34); Person p2("dkfj",1);
        vp.push_back(p1), vp.push_back(p2);
        vector<Person>::iterator po = find(vp.begin(),vp.end(),p1);
        if(po == vp.end()) puts("NO FIND");
        else {
            cout<<po->m_name<<" "<<po->m_age<<endl;
        }
        // find 返回的是迭代器
        

        // find_if
        auto pp = find_if(var.begin(), var.end(),BB());
        if(pp == var.end()) puts("No");
        else puts("FIND");
        auto sdk = find_if(vp.begin(),vp.end(),CP());
        if(sdk == vp.end()) puts("PERSON FND_IF NOT FIND");
        else {
            cout<<sdk->m_name<< " " << sdk->m_age<<endl;
        }

        // adjacent_find  查找相邻重复元素，返回第一个迭代器
        var.insert(var.begin()+3,3);
        for(auto &a: var) cout<<a<<" ";
        puts("");
        auto ask = adjacent_find(var.begin(), var.end());
        if(ask == var.end()) puts("NO");
        else {
            cout<<*ask<<" "<<*(ask+1)<<endl;
        }

        // binary_search() ------
        sort(var.begin(),var.end());
        // bool binary-search(beg, end, val); beg, end ======= iterator
        // 该容器必须是 有序的序列 、、 如果是无序序列，结果未知。

        // count (it beg, it end, val);
        // 统计内置数据
        var.push_back(3), var.push_back(3);
        cout<<count(var.begin(), var.end(),3)<<endl;
        // 统计自定义数据类型时， 要重载 == 
        // 要 重载 == 
        cout<<count(vp.begin(), vp.end(),p1);
}
// 常用的查找算法
class G20{
public:
    bool operator() (int val) {
        return val > 20;
    }
};
class AgeG20 {
public:
    bool operator() (const Person& a) {
        return a.m_age > 20;
    }
};
void testt() {
    vector<int> v;
    v.push_back(10), v.push_back(40), v.push_back(10),v.push_back(30);
    // 统计内置数据类型
    cout<<count_if(v.begin(),v.end(),G20())<<endl;
    vector<Person> vp;
    Person p1("yh",20), p2("ldkfj",54), p3("dklfj",334);
    vp.push_back(p1), vp.push_back(p2), vp.push_back(p3);
    cout<<count_if(vp.begin(), vp.end(),AgeG20())<<endl;

}
// sort random_shuffle merge reverse
void prn(int a) {
    cout<<a<<" ";
}
void ssor() {
    vector<int> v;
    for(int i = 0; i < 100; ++i) {
        srand(i);
        v.push_back(rand() % 101);
    }
    for_each(v.begin(),v.end(),prn); puts("");
    sort(v.begin(), v.end());
    for_each(v.begin(),v.end(),prn); puts("");
    // change less 
    sort(v.begin(), v.end(),greater<int>());
    for_each(v.begin(),v.end(),prn);
    // 利用 洗牌 算法  打乱顺序
         // srand(dklf) 更真实
    srand((unsigned int )time(NULL));
    random_shuffle(v.begin(), v.end());
    for_each(v.begin(), v.end(),prn);puts(""); 
    cout<<"-------------------------"<<endl;
    // merge 合并的两个数组也要 先排好序
    // merge 合并 必须是有序的两个数列
    vector<int> v1, v2;
    for(int i = 0; i < 4; ++i) {
        v1.push_back(rand()%1000), v2.push_back(rand()%34);
    }
    for_each(v1.begin(), v1.end(),prn);
    for_each(v2.begin(),v2.end(), prn); puts("");
    vector<int> vT;
    // 提前分配内存空间
    vT.resize(v1.size() + v2.size());
    merge(v1.begin(),v1.end(),v2.begin(),v2.end(),vT.begin());
    for_each(vT.begin(), vT.end(),prn);

    // reverse();
    reverse(vT.begin(), vT.end());
    puts("");
    for_each(vT.begin(), vT.end(), prn); puts("");    
}
 // 常用copy和替换算法 
class GG3{
public:
    bool operator() (int val) {
        return val > 3;
    }
};
void coop() {
    vector<int> v;
    for(int i = 0; i < 10; ++i) v.push_back(i);
    vector<int> v2;
    v2.resize(v.size());
    // copy 前 记得开辟空间
    copy(v.begin(), v.end(),v2.begin());
    int nums[] = {1,2,3,4,5,5,3,3,4,4};
    replace(nums,nums+10,3,0);
    for_each(nums, nums+10,prn); puts("");
    replace(v.begin(), v.end(),3,3333);
    for_each(v.begin(), v.end(),prn);
    replace_if(v.begin(), v.end(),GG3(), -234324);
    for_each(v.begin(), v.end(),prn); puts("");

    // swap(v1,v2);
}
int main()
{
    coop();

}
