// I feel my answer has  a little flaw, 
// because the test data have four data;
//  it can AC;
// high palindromic number ;
#include <bits/stdc++.h>
using namespace std;
int digit[400];
int cop[400];
int main()
{
    int n;
    cin>>n;//N进制;
    string s;
    cin>>s;
    int k = 0;
    for(int i = s.size() - 1; i >= 0; i--) {//k == s.size();
        if(isdigit(s[i])) {
        digit[k++] = s[i] - '0';}
        else { // 十六进制; // NOTICE: hexadecimal ;
            if(s[i] == 'A') {digit[k++] = 10;}
            if(s[i] == 'B') {digit[k++] = 11;}
            if(s[i] == 'C') {digit[k++] = 12;}
            if(s[i] == 'D') {digit[k++] = 13;}
            if(s[i] == 'E') {digit[k++] = 14;}
            if(s[i] == 'F') {digit[k++] = 15;}
        }
    }
    int ans = 0;
    while(++ans) {
        // compare;
        int j = k;
        for(int i = 0; i <= j/2; i++) {
            if(digit[i] == digit[j-1]) {
                if(i == j/2) {
                    cout<<"STEP="<<ans-1; return 0;
                } else {
                    j--;
                }
            } else {
                //add;
                int kk = 0;
                for(int z = k-1; z >= 0; z--) {
                    cop[kk++] = digit[z];
                }
                for(int z = 0; z < 400; z++) {
                    digit[z] = digit[z] + cop[z];
                    digit[z+1] += digit[z]/n;
                    digit[z] %= n;
                }
                if(digit[k] != 0) {k++;}
                if(digit[k] != 0) {k++;}
                break;
                }
                
            }
            if(ans == 31) { // maybe this row is right; 
                cout<<"Impossible!"; return 0;
            }
        }
    

}
/*
  Let me reverse the palindrome, then add palindrome;
  still true;
  because 
  JUST added them in the opposite order;
  234 + 432 == 432 + 234;
  commutative law of addition 
*/
