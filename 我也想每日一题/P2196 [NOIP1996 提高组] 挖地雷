/**
 * @file Untitled-6
 * @author your name (you@domain.com)
 * @brief 
 * @version 0.1
 * @date 2022-04-04
 * 
 * @copyright Copyright (c) 2022
 * this is a dynamic programming;
 * and approach is an these:
 * sample :
 * 5
 * 10 8 4 7 6
 *    1 1 1 0
 *      0 0 0
 *        1 1
 *          1
 * Firstly judge the first column;
 * the MAX is 10;
 * then the second column is 18;
 * ...14
 * ...21
 * ...27;
 * line DP, and not row, is column;
 * core code is if(Path[j][i] != 0 && f[j] > f[i]) ..;
 * I think the significant is  recall;
 * Emm.. about it, can use print function that I define;
 * that's all;
 */
#include <iostream>
#include <queue>
using namespace std;
int Path[30][30], m, dp[30], ans,boom[29], t, pre[23];
queue<int>p1, p2;
void print(int x) {
    if(pre[x] == 0) {
        cout<<x<<" ";
        return ;
    }
    print(pre[x]);
    cout<<x<<" ";

}
int main()
{
    cin>>m;
    for(int i = 1; i <= m; i++) cin>>boom[i];
    for(int i = 1; i <= m; i++) {
        for(int j = i+1; j <= m; j++) {
            int pock;
            cin>>pock;
            Path[i][j] = pock;
            }
    }
    for(int i = 1; i <= m; i++) {
        for(int j = 1; j <= m; j++) {
            if(Path[j][i] && dp[j] > dp[i]) {
                dp[i] = dp[j];
                pre[i] = j;
            }
        }
        dp[i] += boom[i];
        if(dp[i] > ans) {
            ans = dp[i];
            t = i;
        }
    }
    print(t);
    cout<<endl;
    cout<<ans;

}
